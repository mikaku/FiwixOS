diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/Makefile.inc newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/Makefile.inc
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/Makefile.inc	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/Makefile.inc	2025-04-04 11:56:06 +0000
@@ -0,0 +1,17 @@
+libc_a_SOURCES += \
+	%D%/cfspeed.c \
+	%D%/clock_functions.c \
+	%D%/ftok.c \
+	%D%/grp.c \
+	%D%/ipc.c \
+	%D%/mntent.c \
+	%D%/net_inet_ntoa.c \
+	%D%/ptys.c \
+	%D%/realpath.c \
+	%D%/sigwait.c \
+	%D%/syscalls.c \
+	%D%/system.c \
+	%D%/termios.c \
+	%D%/usershell.c \
+	%D%/utmp.c \
+	%D%/wrappers.c
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/sigaction.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/sigaction.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/sigaction.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/sigaction.h	2025-01-31 08:25:58 +0000
@@ -0,0 +1,79 @@
+/* The proper definitions for Linux's sigaction.
+   Copyright (C) 1993-1999, 2000, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Signal handler.  */
+//#ifdef __USE_POSIX199309
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler	__sigaction_handler.sa_handler
+# define sa_sigaction	__sigaction_handler.sa_sigaction
+//#else
+//    __sighandler_t sa_handler;
+//#endif
+
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+
+    /* Special flags.  */
+    int sa_flags;
+
+    /* Restore handler.  */
+    void (*sa_restorer) (void);
+  };
+
+/* Bits in `sa_flags'.  */
+#define	SA_NOCLDSTOP  1		 /* Don't send SIGCHLD when children stop.  */
+#define SA_NOCLDWAIT  2		 /* Don't create zombie on child death.  */
+#define SA_SIGINFO    4		 /* Invoke signal-catching function with
+				    three arguments instead of one.  */
+#if defined __USE_UNIX98 || defined __USE_MISC
+# define SA_ONSTACK   0x08000000 /* Use signal stack by using `sa_restorer'. */
+#endif
+//#if defined __USE_UNIX98 || defined __USE_MISC || defined __USE_XOPEN2K8
+# define SA_RESTART   0x10000000 /* Restart syscall on signal return.  */
+# define SA_NODEFER   0x40000000 /* Don't automatically block the signal when
+				    its handler is being executed.  */
+# define SA_RESETHAND 0x80000000 /* Reset to SIG_DFL on entry to handler.  */
+//#endif
+#ifdef __USE_MISC
+# define SA_INTERRUPT 0x20000000 /* Historical no-op.  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define	SIG_BLOCK     0		 /* Block signals.  */
+#define	SIG_UNBLOCK   1		 /* Unblock signals.  */
+#define	SIG_SETMASK   2		 /* Set the set of blocked signals.  */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/siginfo.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/siginfo.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/siginfo.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/siginfo.h	2025-01-31 08:25:58 +0000
@@ -0,0 +1,313 @@
+/* siginfo_t, sigevent and constants.  Linux version.
+   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t	1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+# define __SI_MAX_SIZE     128
+# if __WORDSIZE == 64
+#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+
+    union
+      {
+	int _pad[__SI_PAD_SIZE];
+
+	 /* kill().  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	  } _kill;
+
+	/* POSIX.1b timers.  */
+	struct
+	  {
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _timer;
+
+	/* POSIX.1b signals.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _rt;
+
+	/* SIGCHLD.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Which child.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    int si_status;	/* Exit value or signal.  */
+	    unsigned int si_utime;
+	    unsigned int si_stime;
+	  } _sigchld;
+
+	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
+	struct
+	  {
+	    void *si_addr;	/* Faulting insn/memory ref.  */
+	  } _sigfault;
+
+	/* SIGPOLL.  */
+	struct
+	  {
+	    long int si_band;	/* Band event for SIGPOLL.  */
+	    int si_fd;
+	  } _sigpoll;
+      } _sifields;
+  } siginfo_t;
+
+
+/* X/Open requires some more fields with fixed names.  */
+# define si_pid		_sifields._kill.si_pid
+# define si_uid		_sifields._kill.si_uid
+# define si_timerid	_sifields._timer.si_tid
+# define si_overrun	_sifields._timer.si_overrun
+# define si_status	_sifields._sigchld.si_status
+# define si_utime	_sifields._sigchld.si_utime
+# define si_stime	_sifields._sigchld.si_stime
+# define si_value	_sifields._rt.si_sigval
+# define si_int		_sifields._rt.si_sigval.sival_int
+# define si_ptr		_sifields._rt.si_sigval.sival_ptr
+# define si_addr	_sifields._sigfault.si_addr
+# define si_band	_sifields._sigpoll.si_band
+# define si_fd		_sifields._sigpoll.si_fd
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
+# define SI_ASYNCNL	SI_ASYNCNL
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
+  SI_SIGIO,			/* Sent by queued SIGIO. */
+# define SI_SIGIO	SI_SIGIO
+  SI_ASYNCIO,			/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_MESGQ,			/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER,			/* Sent by timer expiration.  */
+# define SI_TIMER	SI_TIMER
+  SI_QUEUE,			/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER,			/* Sent by kill, sigsend, raise.  */
+# define SI_USER	SI_USER
+  SI_KERNEL = 0x80		/* Send by kernel.  */
+#define SI_KERNEL	SI_KERNEL
+};
+
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTDIV = 1,		/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_INTOVF,			/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+/* Structure to transport application-defined values with signals.  */
+# define __SIGEV_MAX_SIZE	64
+# if __WORDSIZE == 64
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+
+    union
+      {
+	int _pad[__SIGEV_PAD_SIZE];
+
+	/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
+	   thread to receive the signal.  */
+	__pid_t _tid;
+
+	struct
+	  {
+	    void (*_function) (sigval_t);	/* Function to start.  */
+	    void *_attribute;			/* Really pthread_attr_t.  */
+	  } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+
+/* POSIX names to access some of the members.  */
+# define sigev_notify_function   _sigev_un._sigev_thread._function
+# define sigev_notify_attributes _sigev_un._sigev_thread._attribute
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE,			/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  SIGEV_THREAD,			/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+
+  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
+#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
+};
+
+#endif	/* have _SIGNAL_H.  */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/signum.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/signum.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/signum.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/signum.h	2025-01-31 08:25:58 +0000
@@ -0,0 +1,82 @@
+/* Signal number definitions.  Linux version.
+   Copyright (C) 1995,1996,1997,1998,1999,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef	_SIGNAL_H
+
+/* Fake signal functions.  */
+#define SIG_ERR	((__sighandler_t) -1)		/* Error return.  */
+#define SIG_DFL	((__sighandler_t) 0)		/* Default action.  */
+#define SIG_IGN	((__sighandler_t) 1)		/* Ignore signal.  */
+
+#ifdef __USE_UNIX98
+# define SIG_HOLD	((__sighandler_t) 2)	/* Add signal to hold mask.  */
+#endif
+
+
+/* Signals.  */
+#define	SIGHUP		1	/* Hangup (POSIX).  */
+#define	SIGINT		2	/* Interrupt (ANSI).  */
+#define	SIGQUIT		3	/* Quit (POSIX).  */
+#define	SIGILL		4	/* Illegal instruction (ANSI).  */
+#define	SIGTRAP		5	/* Trace trap (POSIX).  */
+#define	SIGABRT		6	/* Abort (ANSI).  */
+#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
+#define	SIGBUS		7	/* BUS error (4.2 BSD).  */
+#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
+#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
+#define	SIGUSR1		10	/* User-defined signal 1 (POSIX).  */
+#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
+#define	SIGUSR2		12	/* User-defined signal 2 (POSIX).  */
+#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
+#define	SIGALRM		14	/* Alarm clock (POSIX).  */
+#define	SIGTERM		15	/* Termination (ANSI).  */
+#define	SIGSTKFLT	16	/* Stack fault.  */
+#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
+#define	SIGCHLD		17	/* Child status has changed (POSIX).  */
+#define	SIGCONT		18	/* Continue (POSIX).  */
+#define	SIGSTOP		19	/* Stop, unblockable (POSIX).  */
+#define	SIGTSTP		20	/* Keyboard stop (POSIX).  */
+#define	SIGTTIN		21	/* Background read from tty (POSIX).  */
+#define	SIGTTOU		22	/* Background write to tty (POSIX).  */
+#define	SIGURG		23	/* Urgent condition on socket (4.2 BSD).  */
+#define	SIGXCPU		24	/* CPU limit exceeded (4.2 BSD).  */
+#define	SIGXFSZ		25	/* File size limit exceeded (4.2 BSD).  */
+#define	SIGVTALRM	26	/* Virtual alarm clock (4.2 BSD).  */
+#define	SIGPROF		27	/* Profiling alarm clock (4.2 BSD).  */
+#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
+#define	SIGPOLL		SIGIO	/* Pollable event occurred (System V).  */
+#define	SIGIO		29	/* I/O now possible (4.2 BSD).  */
+#define	SIGPWR		30	/* Power failure restart (System V).  */
+#define SIGSYS		31	/* Bad system call.  */
+#define SIGUNUSED	31
+
+#define NSIG		32      /* signal 0 implied */
+
+#define	_NSIG		65	/* Biggest signal number + 1
+				   (including real-time signals).  */
+
+//#define SIGRTMIN        (__libc_current_sigrtmin ())
+//#define SIGRTMAX        (__libc_current_sigrtmax ())
+
+/* These are the hard limits of the kernel.  These values should not be
+   used directly at user level.  */
+#define __SIGRTMIN	32
+#define __SIGRTMAX	(_NSIG - 1)
+
+#endif	/* <signal.h> included.  */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/ustat.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/ustat.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/ustat.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/ustat.h	2025-01-31 08:25:58 +0000
@@ -0,0 +1,31 @@
+/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USTAT_H
+# error "Never include <bits/ustat.h> directly; use <sys/ustat.h> instead."
+#endif
+
+#include <sys/types.h>
+
+struct ustat
+  {
+    daddr_t f_tfree;		/* Number of free blocks.  */
+    ino_t f_tinode;		/* Number of free inodes.  */
+    char f_fname[6];
+    char f_fpack[6];
+  };
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/wordsize.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/wordsize.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/bits/wordsize.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/bits/wordsize.h	2025-01-31 08:25:58 +0000
@@ -0,0 +1,8 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+#if defined __x86_64__
+# define __WORDSIZE	64
+# define __WORDSIZE_COMPAT32	1
+#else
+# define __WORDSIZE	32
+#endif
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/cfspeed.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/cfspeed.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/cfspeed.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/cfspeed.c	2025-01-31 08:25:58 +0000
@@ -0,0 +1,88 @@
+/* `struct termios' speed frobnication functions.  Linux version.
+   Copyright (C) 1991, 92, 93, 95, 96, 97, 98, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Modified by Jeff Johnston, May 27, 2002 to remove kernel hack
+   as we simply ignore a cfisetspeed of 0 instead of treating it specially */
+
+#include <stddef.h>
+#include <errno.h>
+#include <termios.h>
+
+/* Return the output baud rate stored in *TERMIOS_P.  */
+speed_t
+cfgetospeed (termios_p)
+     const struct termios *termios_p;
+{
+  return termios_p->c_cflag & (CBAUD | CBAUDEX);
+}
+
+/* Return the input baud rate stored in *TERMIOS_P.
+   For Linux there is no difference between input and output
+   speed. */
+speed_t
+cfgetispeed (termios_p)
+     const struct termios *termios_p;
+{
+  return termios_p->c_cflag & (CBAUD | CBAUDEX);
+}
+
+/* Set the output baud rate stored in *TERMIOS_P to SPEED.  */
+int
+cfsetospeed  (termios_p, speed)
+     struct termios *termios_p;
+     speed_t speed;
+{
+  if ((speed & ~CBAUD) != 0
+      && (speed < B57600 || speed > __MAX_BAUD))
+    {
+      errno = (EINVAL);
+      return -1;
+    }
+
+  termios_p->c_cflag &= ~(CBAUD | CBAUDEX);
+  termios_p->c_cflag |= speed;
+
+  return 0;
+}
+
+/* Set the input baud rate stored in *TERMIOS_P to SPEED.
+   Although for Linux there is no difference between input and output
+   speed, the numerical 0 is a special case for the input baud rate.  It
+   should set the input baud rate to the output baud rate so we do
+   nothing. */
+int
+cfsetispeed (termios_p, speed)
+     struct termios *termios_p;
+     speed_t speed;
+{
+  if ((speed & ~CBAUD) != 0
+      && (speed < B57600 || speed > __MAX_BAUD))
+    {
+      errno = (EINVAL);
+      return -1;
+    }
+
+  if (speed != 0)
+    {
+      termios_p->c_cflag &= ~(CBAUD | CBAUDEX);
+      termios_p->c_cflag |= speed;
+    }
+
+  return 0;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/clock_functions.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/clock_functions.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/clock_functions.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/clock_functions.c	2025-01-31 08:25:58 +0000
@@ -0,0 +1,114 @@
+/* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdint.h>
+#include <time.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+/* Get current value of CLOCK and store it in TP.  */
+int
+clock_gettime (clockid_t clock_id, struct timespec *tp)
+{
+  struct timeval tv;
+  int retval = -1;
+
+  switch (clock_id)
+    {
+    case CLOCK_REALTIME:
+    case CLOCK_MONOTONIC: /* fake */
+      retval = gettimeofday (&tv, NULL);
+      if (retval == 0)
+        /* Convert into `timespec'.  */
+        TIMEVAL_TO_TIMESPEC (&tv, tp);
+      break;
+
+    default:
+      __set_errno (EINVAL);
+      break;
+    }
+
+  return retval;
+}
+
+/* Get resolution of clock.  */
+int
+clock_getres (clockid_t clock_id, struct timespec *res)
+{
+  int retval = -1;
+
+  switch (clock_id)
+    {
+    case CLOCK_REALTIME:
+    case CLOCK_MONOTONIC: /* fake */
+      {
+        int clk_tck = sysconf (_SC_CLK_TCK);
+
+        if (__builtin_expect (clk_tck != -1, 1))
+          {
+            /* This implementation assumes that the realtime clock has a
+               resolution higher than 1 second.  This is the case for any
+               reasonable implementation.  */
+            res->tv_sec = 0;
+            res->tv_nsec = 1000000000 / clk_tck;
+
+            retval = 0;
+          }
+      }
+      break;
+
+    default:
+      __set_errno (EINVAL);
+      break;
+    }
+
+  return retval;
+}
+
+/* Set CLOCK to value TP.  */
+int
+clock_settime (clockid_t clock_id, const struct timespec *tp)
+{
+  struct timeval tv;
+  int retval;
+
+  /* Make sure the time cvalue is OK.  */
+  if (tp->tv_nsec < 0 || tp->tv_nsec >= 1000000000)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  switch (clock_id)
+    {
+    case CLOCK_REALTIME:
+    case CLOCK_MONOTONIC: /* fake */
+      TIMESPEC_TO_TIMEVAL (&tv, tp);
+
+      retval = settimeofday (&tv, NULL);
+      break;
+
+    default:
+      __set_errno (EINVAL);
+      retval = -1;
+      break;
+    }
+
+  return retval;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/crt0.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/crt0.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/crt0.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/crt0.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,40 @@
+/*
+ * fiwix/crt0.c
+ *
+ * Copyright 2018-2020, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <fcntl.h>
+ 
+extern char **environ;
+extern char **__argv;
+extern char *__progname;
+
+extern void exit(int);
+extern int main(int argc, char *argv[], char *envp[]);
+ 
+void _start(int esp)
+{
+	int *p;
+	int argc;
+	char **argv;
+	int retval;
+
+	p = &esp;
+	argc = *(--p);
+	argv = (char **)(++p);
+
+	/* helpers for getprogname() */
+	__argv = argv;
+	__progname = argv[0];
+
+	p += argc;
+	environ = (char **)(++p);
+
+	/* run the global constructors */
+	_init();
+
+	retval = main(argc, argv, environ);
+	exit(retval);
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/ftok.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/ftok.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/ftok.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/ftok.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,38 @@
+/* Copyright (C) 1995-2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/stat.h>
+
+/* modified for Newlib by Jordi Sanfeliu, April 2022 */
+
+key_t
+ftok (const char *pathname, int proj_id)
+{
+  struct stat st;
+  key_t key;
+
+  if (stat (pathname, &st) < 0)
+    return (key_t) -1;
+
+  key = ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16)
+	 | ((proj_id & 0xff) << 24));
+
+  return key;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/grp.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/grp.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/grp.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/grp.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,119 @@
+/*
+ * fiwix/grp.c
+ *
+ * Copyright 2018-2020, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <errno.h>
+#include <sys/syslimits.h>
+
+static FILE *f;
+static char *mem[NGROUPS_MAX];
+static struct group g;
+static char line[1024];
+
+
+/* rewind next getgrent back to start of database */
+void setgrent()
+{
+	if(f) {
+		fclose(f);
+	}
+	f = fopen(_PATH_GROUP, "r");
+}
+
+/* release group database resources */
+void endgrent()
+{
+	if(f) {
+		fclose(f);
+	}
+	f = 0;
+}
+
+/* fetch next group */
+struct group *getgrent()
+{
+	char *l, *p;
+	int n;
+
+	memset(line, 0, sizeof(line));
+	if(!(l = fgets(line, sizeof(line) - 1, f))) {
+		return NULL;
+	}
+
+	/* get name */
+	g.gr_name = l;
+	if(!(l = strchr(l, ':'))) {
+		return NULL;
+	}
+	*l++ = '\0';
+
+	/* get password */
+	g.gr_passwd = l;
+	if(!(l = strchr(l, ':'))) {
+		return NULL;
+	}
+	*l++ = '\0';
+
+	/* get group id */
+	p = l;
+	if(!(l = strchr(l, ':'))) {
+		return NULL;
+	}
+	*l++ = '\0';
+	g.gr_gid = atoi(p);
+
+	/* get members */
+	memset(mem, 0, sizeof(mem));
+	g.gr_mem = mem;
+	for(n = 0; *l != '\n' && *l != '\0' && n < NGROUPS_MAX; n++) {
+		mem[n] = l;
+		if((p = strchr(l, ','))) {
+			l = p;
+			*l++ = '\0';
+			continue;
+		}
+		if((l = strchr(l, '\n')) || (l = strchr(l, '\r'))) {
+			*l = '\0';
+			break;
+		}
+	}
+	return(&g);
+}
+
+/* fetch group with given group id */
+struct group *getgrgid(gid_t gid)
+{
+	struct group *g;
+
+	setgrent();
+	while((g = getgrent())) {
+		if(g->gr_gid == gid) {
+			break;
+		}
+	}
+	endgrent();
+	return(g);
+}
+
+/* fetch named group */
+struct group *getgrnam(const char *name)
+{
+	struct group *g;
+
+	setgrent();
+	while((g = getgrent())) {
+		if(!strcmp(g->gr_name, name)) {
+			break;
+		}
+	}
+	endgrent();
+	return(g);
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/arpa/inet.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/arpa/inet.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/arpa/inet.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/arpa/inet.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * -
+ * Portions Copyright (c) 1993 by Digital Equipment Corporation.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies, and that
+ * the name of Digital Equipment Corporation not be used in advertising or
+ * publicity pertaining to distribution of the document or software without
+ * specific, written prior permission.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
+ * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
+ * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ *	@(#)inet.h	8.1 (Berkeley) 6/2/93
+ *	From: Id: inet.h,v 8.5 1997/01/29 08:48:09 vixie Exp $
+ * $FreeBSD: src/include/arpa/inet.h,v 1.22 2002/04/10 10:51:53 mike Exp $
+ */
+
+#ifndef _ARPA_INET_H_
+#define	_ARPA_INET_H_
+
+/* External definitions for functions in inet(3), addr2ascii(3) */
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <machine/ansi.h>
+
+/* Required for byteorder(3) functions. */
+#include <machine/endian.h>
+
+#define	INET_ADDRSTRLEN		16
+#define	INET6_ADDRSTRLEN	46
+
+#ifndef _UINT16_T_DECLARED
+typedef	__uint16_t	uint16_t;
+#define	_UINT16_T_DECLARED
+#endif
+
+#ifndef _UINT32_T_DECLARED
+typedef	__uint32_t	uint32_t;
+#define	_UINT32_T_DECLARED
+#endif
+
+#ifndef	_IN_ADDR_T_DECLARED
+typedef	uint32_t	in_addr_t;
+#define	_IN_ADDR_T_DECLARED
+#endif
+
+#ifndef	_IN_PORT_T_DECLARED
+typedef	uint16_t	in_port_t;
+#define	_IN_PORT_T_DECLARED
+#endif
+
+#ifndef _POSIX_SOURCE
+#ifdef	_BSD_SIZE_T_
+typedef	_BSD_SIZE_T_	size_t;
+#undef	_BSD_SIZE_T_
+#endif
+#endif /* !_POSIX_SOURCE */
+
+/*
+ * XXX socklen_t is used by a POSIX.1-2001 interface, but not required by
+ * POSIX.1-2001.
+ */
+
+
+#ifndef __socklen_t_defined
+typedef unsigned int socklen_t;
+#define __socklen_t_defined 1
+#endif
+
+#ifdef	_BSD_SOCKLEN_T_
+typedef	_BSD_SOCKLEN_T_	socklen_t;
+#undef	_BSD_SOCKLEN_T_
+#endif
+
+#ifndef _STRUCT_IN_ADDR_DECLARED
+struct in_addr {
+	in_addr_t s_addr;
+};
+#define	_STRUCT_IN_ADDR_DECLARED
+#endif
+
+#define	inet_addr	__inet_addr
+#define	inet_aton	__inet_aton
+#define	inet_lnaof	__inet_lnaof
+#define	inet_makeaddr	__inet_makeaddr
+#define	inet_neta	__inet_neta
+#define	inet_netof	__inet_netof
+#define	inet_network	__inet_network
+#define	inet_net_ntop	__inet_net_ntop
+#define	inet_net_pton	__inet_net_pton
+#define	inet_ntoa	__inet_ntoa
+#define	inet_pton	__inet_pton
+#define	inet_ntop	__inet_ntop
+#define	inet_nsap_addr	__inet_nsap_addr
+#define	inet_nsap_ntoa	__inet_nsap_ntoa
+
+__BEGIN_DECLS
+in_addr_t	 inet_addr(const char *);
+char		*inet_ntoa(struct in_addr);
+const char	*inet_ntop(int, const void *, char *, socklen_t);
+int		 inet_pton(int, const char *, void *);
+
+int		 ascii2addr(int, const char *, void *);
+char		*addr2ascii(int, const void *, int, char *);
+int		 inet_aton(const char *, struct in_addr *);
+in_addr_t	 inet_lnaof(struct in_addr);
+struct in_addr	 inet_makeaddr(in_addr_t, in_addr_t);
+char *		 inet_neta(in_addr_t, char *, size_t);
+in_addr_t	 inet_netof(struct in_addr);
+in_addr_t	 inet_network(const char *);
+char		*inet_net_ntop(int, const void *, int, char *, size_t);
+int		 inet_net_pton(int, const char *, void *, size_t);
+unsigned	 inet_nsap_addr(const char *, unsigned char *, int);
+char		*inet_nsap_ntoa(int, const unsigned char *, char *);
+__END_DECLS
+
+#endif /* !_ARPA_INET_H_ */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/err.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/err.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/err.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/err.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,94 @@
+#ifndef	_ERR_H
+#define	_ERR_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+extern char *__progname;
+
+void __generic_err(const char *format, va_list args)
+{
+	fprintf(stderr, "%s: ", __progname);
+	if(format) {
+		vfprintf(stderr, format, args);
+	}
+	perror(" ");
+	fprintf(stderr, "\n");
+}
+
+void __generic_errx(const char *format, va_list args)
+{
+	fprintf(stderr, "%s: ", __progname);
+	if(format) {
+		vfprintf(stderr, format, args);
+	}
+	fprintf(stderr, "\n");
+}
+
+
+/* print "program: ", *format, ": ", and the errno string */
+void err(int eval, const char *format, ...)
+{
+	va_list args;
+
+	va_start(args, format);
+	__generic_err(format, args);
+	va_end(args);
+	exit(eval);	/* do not return */
+}
+
+void warn(const char *format, ...)
+{
+	va_list args;
+
+	va_start(args, format);
+	__generic_err(format, args);
+	va_end(args);
+}
+
+void verr(int eval, const char *format, va_list args)
+{
+	__generic_err(format, args);
+	exit(eval);	/* do not return */
+}
+
+void vwarn(const char *format, va_list args)
+{
+	__generic_err(format, args);
+}
+
+
+/* likewise, but without ": " and without the errno string */
+void errx(int eval, const char *format, ...)
+{
+	va_list args;
+
+	va_start(args, format);
+	__generic_errx(format, args);
+	va_end(args);
+	exit(eval);	/* do not return */
+}
+
+void warnx(const char *format, ...)
+{
+	va_list args;
+
+	va_start(args, format);
+	__generic_errx(format, args);
+	va_end(args);
+}
+
+void verrx(int eval, const char *format, va_list args)
+{
+	__generic_errx(format, args);
+	exit(eval);	/* do not return */
+}
+
+void vwarnx(const char *format, va_list args)
+{
+	__generic_errx(format, args);
+}
+
+#endif /* _ERR_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/features.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/features.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/features.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/features.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1 @@
+#include <sys/features.h>
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/limits.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/limits.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/limits.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/limits.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,274 @@
+/* Copyright (C) 1991, 1992, 1993, 1996, 1997, 1998, 1999, 2000, 2001,
+   2002 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _LIMITS_H___
+#define _LIMITS_H___
+
+/* Number of bits in a `char'.  */
+#undef CHAR_BIT
+#define CHAR_BIT __CHAR_BIT__
+
+/* Maximum length of a multibyte character.  */
+#ifndef MB_LEN_MAX
+#define MB_LEN_MAX 1
+#endif
+
+/* Minimum and maximum values a `signed char' can hold.  */
+#undef SCHAR_MIN
+#define SCHAR_MIN (-SCHAR_MAX - 1)
+#undef SCHAR_MAX
+#define SCHAR_MAX __SCHAR_MAX__
+
+/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
+#undef UCHAR_MAX
+#if __SCHAR_MAX__ == __INT_MAX__
+# define UCHAR_MAX (SCHAR_MAX * 2U + 1U)
+#else
+# define UCHAR_MAX (SCHAR_MAX * 2 + 1)
+#endif
+
+/* Minimum and maximum values a `char' can hold.  */
+#ifdef __CHAR_UNSIGNED__
+# undef CHAR_MIN
+# if __SCHAR_MAX__ == __INT_MAX__
+#  define CHAR_MIN 0U
+# else
+#  define CHAR_MIN 0
+# endif
+# undef CHAR_MAX
+# define CHAR_MAX UCHAR_MAX
+#else
+# undef CHAR_MIN
+# define CHAR_MIN SCHAR_MIN
+# undef CHAR_MAX
+# define CHAR_MAX SCHAR_MAX
+#endif
+
+/* Minimum and maximum values a `signed short int' can hold.  */
+#undef SHRT_MIN
+#define SHRT_MIN (-SHRT_MAX - 1)
+#undef SHRT_MAX
+#define SHRT_MAX __SHRT_MAX__
+
+/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
+#undef USHRT_MAX
+#if __SHRT_MAX__ == __INT_MAX__
+# define USHRT_MAX (SHRT_MAX * 2U + 1U)
+#else
+# define USHRT_MAX (SHRT_MAX * 2 + 1)
+#endif
+
+/* Minimum and maximum values a `signed int' can hold.  */
+#undef INT_MIN
+#define INT_MIN (-INT_MAX - 1)
+#undef INT_MAX
+#define INT_MAX __INT_MAX__
+
+/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
+#undef UINT_MAX
+#define UINT_MAX (INT_MAX * 2U + 1U)
+
+/* Minimum and maximum values a `signed long int' can hold.
+   (Same as `int').  */
+#undef LONG_MIN
+#define LONG_MIN (-LONG_MAX - 1L)
+#undef LONG_MAX
+#define LONG_MAX __LONG_MAX__
+
+/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
+#undef ULONG_MAX
+#define ULONG_MAX (LONG_MAX * 2UL + 1UL)
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+/* Minimum and maximum values a `signed long long int' can hold.  */
+# undef LLONG_MIN
+# define LLONG_MIN (-LLONG_MAX - 1LL)
+# undef LLONG_MAX
+# define LLONG_MAX __LONG_LONG_MAX__
+
+/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
+# undef ULLONG_MAX
+# define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
+#endif
+
+#if defined (__GNU_LIBRARY__) ? defined (__USE_GNU) : !defined (__STRICT_ANSI__)
+/* Minimum and maximum values a `signed long long int' can hold.  */
+# undef LONG_LONG_MIN
+# define LONG_LONG_MIN (-LONG_LONG_MAX - 1LL)
+# undef LONG_LONG_MAX
+# define LONG_LONG_MAX __LONG_LONG_MAX__
+
+/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
+# undef ULONG_LONG_MAX
+# define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)
+#endif
+
+#endif /* _LIMITS_H___ */
+
+
+/* here is a copy (almost verbatim) of the 'limits.h' file of Newlib 3.1.0 */
+
+#ifndef _LIBC_LIMITS_H_
+# define _LIBC_LIMITS_H_	1
+
+#include <newlib.h>
+#include <sys/cdefs.h>
+#include <sys/syslimits.h>
+
+# ifdef _MB_LEN_MAX
+#  define MB_LEN_MAX	_MB_LEN_MAX
+# else
+#  define MB_LEN_MAX    1
+# endif
+
+/* Maximum number of positional arguments, if _WANT_IO_POS_ARGS.  */
+# ifndef NL_ARGMAX
+#  define NL_ARGMAX 32
+# endif
+
+/* if do not have #include_next support, then we
+   have to define the limits here. */
+# if !defined __GNUC__ || __GNUC__ < 2
+
+#  ifndef _LIMITS_H
+#   define _LIMITS_H	1
+
+#   include <sys/config.h>
+
+/* Number of bits in a `char'.  */
+#   undef CHAR_BIT
+#   define CHAR_BIT 8
+
+/* Minimum and maximum values a `signed char' can hold.  */
+#   undef SCHAR_MIN
+#   define SCHAR_MIN (-128)
+#   undef SCHAR_MAX
+#   define SCHAR_MAX 127
+
+/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
+#   undef UCHAR_MAX
+#   define UCHAR_MAX 255
+
+/* Minimum and maximum values a `char' can hold.  */
+#   ifdef __CHAR_UNSIGNED__
+#    undef CHAR_MIN
+#    define CHAR_MIN 0
+#    undef CHAR_MAX
+#    define CHAR_MAX 255
+#   else
+#    undef CHAR_MIN
+#    define CHAR_MIN (-128)
+#    undef CHAR_MAX
+#    define CHAR_MAX 127
+#   endif
+
+/* Minimum and maximum values a `signed short int' can hold.  */
+#   undef SHRT_MIN
+/* For the sake of 16 bit hosts, we may not use -32768 */
+#   define SHRT_MIN (-32767-1)
+#   undef SHRT_MAX
+#   define SHRT_MAX 32767
+
+/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
+#   undef USHRT_MAX
+#   define USHRT_MAX 65535
+
+/* Minimum and maximum values a `signed int' can hold.  */
+#   ifndef __INT_MAX__
+#    define __INT_MAX__ 2147483647
+#   endif
+#   undef INT_MIN
+#   define INT_MIN (-INT_MAX-1)
+#   undef INT_MAX
+#   define INT_MAX __INT_MAX__
+
+/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
+#   undef UINT_MAX
+#   define UINT_MAX (INT_MAX * 2U + 1)
+
+/* Minimum and maximum values a `signed long int' can hold.
+   (Same as `int').  */
+#   ifndef __LONG_MAX__
+#    if defined (__alpha__) || (defined (__sparc__) && defined(__arch64__)) || defined (__sparcv9)
+#     define __LONG_MAX__ 9223372036854775807L
+#    else
+#     define __LONG_MAX__ 2147483647L
+#    endif /* __alpha__ || sparc64 */
+#   endif
+#   undef LONG_MIN
+#   define LONG_MIN (-LONG_MAX-1)
+#   undef LONG_MAX
+#   define LONG_MAX __LONG_MAX__
+
+/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
+#   undef ULONG_MAX
+#   define ULONG_MAX (LONG_MAX * 2UL + 1)
+
+#   ifndef __LONG_LONG_MAX__
+#    define __LONG_LONG_MAX__ 9223372036854775807LL
+#   endif
+
+#   if __ISO_C_VISIBLE >= 1999
+/* Minimum and maximum values a `signed long long int' can hold.  */
+#    undef LLONG_MIN
+#    define LLONG_MIN (-LLONG_MAX-1)
+#    undef LLONG_MAX
+#    define LLONG_MAX __LONG_LONG_MAX__
+
+/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
+#    undef ULLONG_MAX
+#    define ULLONG_MAX (LLONG_MAX * 2ULL + 1)
+#   endif
+
+#  if __GNU_VISIBLE
+/* Minimum and maximum values a `signed long long int' can hold.  */
+#    undef LONG_LONG_MIN
+#    define LONG_LONG_MIN (-LONG_LONG_MAX-1)
+#    undef LONG_LONG_MAX
+#    define LONG_LONG_MAX __LONG_LONG_MAX__
+
+/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
+#    undef ULONG_LONG_MAX
+#    define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1)
+#   endif
+
+#  endif /* _LIMITS_H  */
+# endif	 /* GCC 2.  */
+
+#endif	 /* !_LIBC_LIMITS_H_ */
+
+
+#ifndef _POSIX2_RE_DUP_MAX
+/* The maximum number of repeated occurrences of a regular expression
+ *    permitted when using the interval notation `\{M,N\}'.  */
+#define _POSIX2_RE_DUP_MAX              255
+#endif /* _POSIX2_RE_DUP_MAX  */
+
+#ifndef ARG_MAX
+#define ARG_MAX		4096
+#endif
+
+#ifndef PATH_MAX
+#define PATH_MAX	1024
+#endif
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/machine/_types.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/machine/_types.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/machine/_types.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/machine/_types.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,36 @@
+#ifndef _MACHINE__TYPES_H
+#define	_MACHINE__TYPES_H
+
+#include <machine/_default_types.h>
+
+typedef	__uint32_t	__blkcnt_t;
+#define	__machine_blkcnt_t_defined
+
+typedef	__int32_t	__blksize_t;
+#define	__machine_blksize_t_defined
+
+typedef	__int16_t	__dev_t;
+#define	__machine_dev_t_defined
+
+typedef	__int32_t	_off_t;
+#define	__machine_off_t_defined
+
+typedef	_off_t		_fpos_t;
+#define	__machine_fpos_t_defined
+
+typedef	__uint32_t	__ino_t;
+#define	__machine_ino_t_defined
+
+typedef	__uint32_t	__mode_t;
+#define	__machine_mode_t_defined
+
+typedef	__uint32_t	_CLOCK_T_;
+#define	__machine_clock_t_defined
+
+typedef	int		_CLOCKID_T_;
+#define	__machine_clockid_t_defined
+
+typedef __intmax_t	_loff_t;
+typedef __uintmax_t	__ino64_t;
+
+#endif /* _MACHINE__TYPES_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/machine/termbits.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/machine/termbits.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/machine/termbits.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/machine/termbits.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,171 @@
+#ifndef _MACHINE_TERMBITS_H
+#define _MACHINE_TERMBITS_H
+
+/* These definitions match those used by the 4.4 BSD kernel.
+   If the operating system has termios system calls or ioctls that
+   correctly implement the POSIX.1 behavior, there should be a
+   system-dependent version of this file that defines `struct termios',
+   `tcflag_t', `cc_t', `speed_t' and the `TC*' constants appropriately.  */
+
+/* Type of terminal control flag masks. */
+typedef unsigned int tcflag_t;
+
+/* Type of control characters. */
+typedef unsigned char cc_t;
+
+/* Type of baud rate specifiers. */
+typedef int speed_t;
+
+/* c_iflag bits */
+#define IGNBRK	0000001		/* Ignore break condition */
+#define BRKINT	0000002		/* Signal interrupt on break */
+#define IGNPAR	0000004		/* Ignore characters with parity errors */
+#define PARMRK	0000010		/* Mark parity and framing errors */
+#define INPCK	0000020		/* Enable input parity check */
+#define ISTRIP	0000040		/* Strip 8th bit off characters */
+#define INLCR	0000100		/* Map NL to CR on input */
+#define IGNCR	0000200		/* Ignore CR */
+#define ICRNL	0000400		/* Map CR to NL on input */
+#define IUCLC	0001000		/* Convert to lowercase */
+#define IXON	0002000		/* Enable start/stop output control */
+#define IXANY	0004000		/* Any character will restart after stop */
+#define IXOFF	0010000		/* Enable start/stop input control */
+#define IMAXBEL	0020000		/* Ring bell when input queue is full */
+
+/* c_oflag bits */
+#define OPOST	0000001		/* enable postprocessing of output (perform output processing) */
+#define OLCUC	0000002		/* map lowercase to uppercase */
+#define ONLCR	0000004		/* map NL (newline) to CR-NL, newline on output */
+#define OCRNL	0000010		/* map CR (carriage return) to NL on output */
+#define ONOCR	0000020		/* no CR output when at column 0 */
+#define ONLRET	0000040		/* NL performs also CR function */
+#define OFILL	0000100		/* use fill characters for delay */
+#define OFDEL	0000200		/* fills are DEL (delete), otherwise NUL (null) */
+#define NLDLY	0000400		/* NL delay mask */
+#define   NL0	0000000		/* no delay after NL */
+#define   NL1	0000400		/* 1 character delay after NL */
+#define CRDLY	0003000		/* CR delay mask */
+#define   CR0	0000000		/* no delay after CR */
+#define   CR1	0001000		/* 1 character delay after CR */
+#define   CR2	0002000		/* 2 characters delay after CR */
+#define   CR3	0003000		/* 3 characters delay after CR */
+#define TABDLY	0014000		/* horizontal TAB delay mask */
+#define   TAB0	0000000		/* no delay after TAB */
+#define   TAB1	0004000		/* 1 character delay after TAB */
+#define   TAB2	0010000		/* 2 characters delay after TAB */
+#define   TAB3	0014000		/* 3 characters delay after TAB */
+#define   XTABS	0014000
+#define BSDLY	0020000		/* BS (backspace) delay mask */
+#define   BS0	0000000		/* no delay after BS */
+#define   BS1	0020000		/* 1 character delay after BS */
+#define VTDLY	0040000		/* vertical TAB delay mask */
+#define   VT0	0000000		/* no delay after vertical TAB */
+#define   VT1	0040000		/* 1 character delay after vertical TAB */
+#define FFDLY	0100000		/* FF (form-feed) delay mask */
+#define   FF0	0000000		/* no delay after FF */
+#define   FF1	0100000		/* 1 character delay after FF */
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017		/* line speed mask */
+#define  B0	0000000		/* hang up */
+#define  B50	0000001		/* 50 baud */
+#define  B75	0000002		/* 75 baud */
+#define  B110	0000003		/* 110 baud */
+#define  B134	0000004		/* 134 baud */
+#define  B150	0000005		/* 150 baud */
+#define  B200	0000006		/* 200 baud */
+#define  B300	0000007		/* 300 baud */
+#define  B600	0000010		/* 600 baud */
+#define  B1200	0000011		/* 1200 baud */
+#define  B1800	0000012		/* 1800 baud */
+#define  B2400	0000013		/* 2400 baud */
+#define  B4800	0000014		/* 4800 baud */
+#define  B9600	0000015		/* 9600 baud */
+#define  B19200	0000016		/* 19200 baud */
+#define  B38400	0000017		/* 38400 baud */
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060		/* number of bits per byte (mask) */
+#define   CS5	0000000		/* 5 bits per byte */
+#define   CS6	0000020		/* 6 bits per byte */
+#define   CS7	0000040		/* 7 bits per byte */
+#define   CS8	0000060		/* 8 bits per byte */
+#define CSTOPB	0000100		/* send two stop bits instead of one */
+#define CREAD	0000200		/* enable receiver */
+#define PARENB	0000400		/* transmit parity enable */
+#define PARODD	0001000		/* odd parity instead of even */
+#define HUPCL	0002000		/* hang up on last close */
+#define CLOCAL	0004000		/* local line (ignore modem status lines) */
+#define CBAUDEX 0010000
+#define  B57600 0010001		/* 57600 baud */
+#define  B115200 0010002	/* 115200 baud */
+#define  B230400 0010003
+#define  B460800 0010004
+#define  B500000 0010005
+#define  B576000 0010006
+#define  B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000	/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000	/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001		/* enable signals */
+#define ICANON	0000002		/* canonical input (do erase and kill processing) */
+#define XCASE	0000004		/* canonical uper/lowercase */
+#define ECHO	0000010		/* enable echo */
+#define ECHOE	0000020		/* echo erase as bs-sp-bs (visual erase for ERASE) */
+#define ECHOK	0000040		/* echo NL after KILL */
+#define ECHONL	0000100		/* echo NL even if echo is OFF */
+#define NOFLSH	0000200		/* disable flush after interrupt or quit */
+#define TOSTOP	0000400		/* Send SIGTTOU to background processes that write to terminal */
+#define ECHOCTL	0001000		/* Echo control characters as ^X */
+#define ECHOPRT	0002000		/* Hardcopy visual erase */
+#define ECHOKE	0004000		/* Visual erase for KILL */
+#define FLUSHO	0010000		/* Output being flushed (state) */
+#define PENDIN	0040000		/* Retype pending input (state) */
+#define IEXTEN	0100000		/* Enable DISCARD and LNEXT */
+
+/* c_cc characters */
+#define VINTR		0	/* Interrupt character [ISIG] */
+#define VQUIT		1	/* Quit character [ISIG] */
+#define VERASE		2	/* Erase character [ICANON] */
+#define VKILL		3	/* Kill-line character [ICANON] */
+#define VEOF		4	/* End-of-file character [ICANON] */
+#define VTIME		5	/* Time-out value (1/10 secs) [!ICANON] */
+#define VMIN		6	/* Minimum # of bytes read at once [!ICANON] */
+#define VSWTC		7
+#define VSTART		8	/* Start (X-ON) character [IXON, IXOFF] */
+#define VSTOP		9	/* Stop (X-OFF) character [IXON, IXOFF] */
+#define VSUSP		10	/* Suspend character [ISIG] */
+#define VEOL		11	/* End-of-line character [ICANON] */
+#define VREPRINT	12	/* Reprint-line character [ICANON] */
+#define VDISCARD	13	/* Discard character [IEXTEN] */
+#define VWERASE		14	/* Word-erase character [ICANON] */
+#define VLNEXT		15	/* Literal-next character [IEXTEN] */
+#define VEOL2		16	/* Second EOL character [ICANON] */
+
+/* Values for the ACTION argument to `tcflow'.  */
+#define TCOOFF		0	/* Suspend output */
+#define TCOON		1	/* Restart suspended output */
+#define TCIOFF		2	/* Send a STOP character */
+#define TCION		3	/* Send a START character */
+
+/* Values for the QUEUE_SELECTOR argument to `tcflush'.  */
+#define TCIFLUSH	0	/* Discard data received but not yet read */
+#define TCOFLUSH	1	/* Discard data written but not yet sent */
+#define TCIOFLUSH	2	/* Discard all pending data */
+
+/* Values for the OPTIONAL_ACTIONS argument to `tcsetattr'.  */
+#define TCSANOW		0	/* Change immediately */
+#define TCSADRAIN	1	/* Change when pending output is written */
+#define TCSAFLUSH	2	/* Flush pending input before changing */
+
+#endif /* _MACHINE_TERMBITS_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/mntent.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/mntent.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/mntent.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/mntent.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,27 @@
+#ifndef _MNTENT_H
+#define _MNTENT_H
+
+#include <stdio.h>
+#include <paths.h>
+
+#define MNTTAB	_PATH_MNTTAB
+#define MOUNTED	_PATH_MOUNTED
+
+/* generic mount options */
+#define MNTOPT_RO	"ro"	/* read only */
+
+struct mntent {
+	char *mnt_fsname;	/* device name */
+	char *mnt_dir;		/* mounting point */
+	char *mnt_type;		/* filesystem type */
+	char *mnt_opts;		/* comma-separated list of mount options */
+	int mnt_freq;		/* dump frequency (in days) */
+	int mnt_passno;		/* pass number on parallel fsck */
+};
+
+FILE *setmntent(const char *, const char *);
+int endmntent(FILE *);
+struct mntent *getmntent(FILE *);
+char *hasmntopt(const struct mntent *, const char *);
+
+#endif	/* _MNTENT_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/netdb.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/netdb.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/netdb.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/netdb.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,287 @@
+/*-
+ * Copyright (c) 1980, 1983, 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * -
+ * Portions Copyright (c) 1993 by Digital Equipment Corporation.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies, and that
+ * the name of Digital Equipment Corporation not be used in advertising or
+ * publicity pertaining to distribution of the document or software without
+ * specific, written prior permission.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
+ * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
+ * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ * -
+ * --Copyright--
+ */
+
+/*
+ *      @(#)netdb.h	8.1 (Berkeley) 6/2/93
+ *      From: Id: netdb.h,v 8.9 1996/11/19 08:39:29 vixie Exp $
+ * $FreeBSD: src/include/netdb.h,v 1.23 2002/03/23 17:24:53 imp Exp $
+ */
+
+#ifndef _NETDB_H_
+#define _NETDB_H_
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <machine/ansi.h>
+#include <stdio.h>
+
+#ifndef __socklen_t_defined
+typedef unsigned int socklen_t;
+#define __socklen_t_defined 1
+#endif
+
+#ifdef	_BSD_SOCKLEN_T_
+typedef	_BSD_SOCKLEN_T_	socklen_t;
+#undef	_BSD_SOCKLEN_T_
+#endif
+
+#ifndef _PATH_HEQUIV
+# define	_PATH_HEQUIV	"/etc/hosts.equiv"
+#endif
+#define	_PATH_HOSTS	"/etc/hosts"
+#define	_PATH_NETWORKS	"/etc/networks"
+#define	_PATH_PROTOCOLS	"/etc/protocols"
+#define	_PATH_SERVICES	"/etc/services"
+#define _PATH_NSSWITCH_CONF  "/etc/nsswitch.conf"
+
+
+extern int *__h_errno_location(void);
+
+#define h_errno (*(__h_errno_location()))
+
+#define	MAXALIASES	35
+  /* For now, only support one return address. */
+#define MAXADDRS         2
+/*
+ * Structures returned by network data base library.  All addresses are
+ * supplied in host order, and returned in network order (suitable for
+ * use in system calls).
+ */
+struct hostent {
+  char	*h_name;	/* official name of host */
+  char	**h_aliases;	/* alias list */
+  int	h_addrtype;	/* host address type */
+  int	h_length;	/* length of address */
+  char	**h_addr_list;	/* list of addresses from name server */
+  char *h_addr;         /* address, for backward compatibility */
+  /* private data, for re-entrancy */
+  char *__host_addrs[MAXADDRS];
+  char *__host_aliases[MAXALIASES];
+  unsigned int __host_addr[4];
+};
+
+/*
+ * Assumption here is that a network number
+ * fits in an unsigned long -- probably a poor one.
+ */
+struct netent {
+	char		*n_name;	/* official name of net */
+	char		**n_aliases;	/* alias list */
+	int		n_addrtype;	/* net address type */
+	unsigned long	n_net;		/* network # */
+};
+
+struct servent {
+	char	*s_name;	/* official service name */
+	char	**s_aliases;	/* alias list */
+	int	s_port;		/* port # */
+	char	*s_proto;	/* protocol to use */
+};
+
+struct protoent {
+	char	*p_name;	/* official protocol name */
+	char	**p_aliases;	/* alias list */
+	int	p_proto;	/* protocol # */
+};
+
+struct addrinfo {
+	int	ai_flags;	/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
+	int	ai_family;	/* PF_xxx */
+	int	ai_socktype;	/* SOCK_xxx */
+	int	ai_protocol;	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */
+	size_t	ai_addrlen;	/* length of ai_addr */
+	char	*ai_canonname;	/* canonical name for hostname */
+	struct	sockaddr *ai_addr;	/* binary address */
+	struct	addrinfo *ai_next;	/* next structure in linked list */
+};
+
+/*
+ * Error return codes from gethostbyname() and gethostbyaddr()
+ * (left in extern int h_errno).
+ */
+
+#define	NETDB_INTERNAL	-1	/* see errno */
+#define	NETDB_SUCCESS	0	/* no problem */
+#define	HOST_NOT_FOUND	1 /* Authoritative Answer Host not found */
+#define	TRY_AGAIN	2 /* Non-Authoritative Host not found, or SERVERFAIL */
+#define	NO_RECOVERY	3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
+#define	NO_DATA		4 /* Valid name, no data record of requested type */
+#define	NO_ADDRESS	NO_DATA		/* no address, look for MX record */
+
+/*
+ * Error return codes from getaddrinfo()
+ */
+/* Error values for `getaddrinfo' function.  */
+# define EAI_BADFLAGS     -1    /* Invalid value for `ai_flags' field.  */
+# define EAI_NONAME       -2    /* NAME or SERVICE is unknown.  */
+# define EAI_AGAIN        -3    /* Temporary failure in name resolution.  */
+# define EAI_FAIL         -4    /* Non-recoverable failure in name res.  */
+# define EAI_NODATA       -5    /* No address associated with NAME.  */
+# define EAI_FAMILY       -6    /* `ai_family' not supported.  */
+# define EAI_SOCKTYPE     -7    /* `ai_socktype' not supported.  */
+# define EAI_SERVICE      -8    /* SERVICE not supported for `ai_socktype'.  */
+# define EAI_ADDRFAMILY   -9    /* Address family for NAME not supported.  */
+# define EAI_MEMORY       -10   /* Memory allocation failure.  */
+# define EAI_SYSTEM       -11   /* System error returned in `errno'.  */
+# define EAI_OVERFLOW     -12   /* Argument buffer overflow.  */
+# ifdef __USE_GNU
+#  define EAI_INPROGRESS  -100  /* Processing request in progress.  */
+#  define EAI_CANCELED    -101  /* Request canceled.  */
+#  define EAI_NOTCANCELED -102  /* Request not canceled.  */
+#  define EAI_ALLDONE     -103  /* All requests done.  */
+#  define EAI_INTR        -104  /* Interrupted by a signal.  */
+#  define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
+# endif
+
+/*
+ * Flag values for getaddrinfo()
+ */
+#define	AI_PASSIVE	0x00000001 /* get address to use bind() */
+#define	AI_CANONNAME	0x00000002 /* fill ai_canonname */
+#define	AI_NUMERICHOST	0x00000004 /* prevent name resolution */
+#define AI_NUMERICSERV  0x00000008 /* don't use name resolution. */
+/* valid flags for addrinfo */
+#define AI_MASK \
+    (AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_ADDRCONFIG)
+
+#define	AI_ALL		0x00000100 /* IPv6 and IPv4-mapped (with AI_V4MAPPED) */
+#define	AI_V4MAPPED_CFG	0x00000200 /* accept IPv4-mapped if kernel supports */
+#define	AI_ADDRCONFIG	0x00000400 /* only if any address is assigned */
+#define	AI_V4MAPPED	0x00000800 /* accept IPv4-mapped IPv6 address */
+/* special recommended flags for getipnodebyname */
+#define	AI_DEFAULT	(AI_V4MAPPED_CFG | AI_ADDRCONFIG)
+
+/*
+ * Constants for getnameinfo()
+ */
+#define	NI_MAXHOST	1025
+#define	NI_MAXSERV	32
+
+/*
+ * Flag values for getnameinfo()
+ */
+#define	NI_NOFQDN	0x00000001
+#define	NI_NUMERICHOST	0x00000002
+#define	NI_NAMEREQD	0x00000004
+#define	NI_NUMERICSERV	0x00000008
+#define	NI_DGRAM	0x00000010
+#define NI_WITHSCOPEID	0x00000020
+
+/*
+ * Scope delimit character
+ */
+#define	SCOPE_DELIMITER	'%'
+
+__BEGIN_DECLS
+void		endhostent(void);
+void		endhostent_r(FILE **, int *);
+void		endnetent(void);
+void		endnetgrent(void);
+void		endprotoent(void);
+void		endservent(void);
+void		freehostent(struct hostent *);
+struct hostent	*gethostbyaddr(const void *, socklen_t, int);
+struct hostent	*gethostbyname(const char *);
+struct hostent	*gethostbyname2(const char *, int);
+struct hostent	*gethostent(void);
+int             gethostent_r(struct hostent *, char *, int, int *, FILE **);
+struct hostent	*getipnodebyaddr(const void *, size_t, int, int *);
+struct hostent	*getipnodebyname(const char *, int, int, int *);
+struct netent	*getnetbyaddr(uint32_t, int);
+struct netent	*getnetbyname(const char *);
+struct netent	*getnetent(void);
+int		getnetgrent(char **, char **, char **);
+struct protoent	*getprotobyname(const char *);
+struct protoent	*getprotobynumber(int);
+struct protoent	*getprotoent(void);
+struct servent	*getservbyname(const char *, const char *);
+struct servent	*getservbyport(int, const char *);
+struct servent	*getservent(void);
+void		herror(const char *);
+__const char	*hstrerror(int);
+int		innetgr(const char *, const char *, const char *, const char *);
+void		sethostent(int);
+void		sethostent_r(int, FILE **, int *);
+/* void		sethostfile(const char *); */
+void		setnetent(int);
+void		setprotoent(int);
+int		getaddrinfo(const char *__restrict, const char *__restrict,
+			    const struct addrinfo *__restrict,
+			    struct addrinfo **__restrict);
+int		getnameinfo(const struct sockaddr *__restrict, socklen_t,
+			    char *__restrict, socklen_t, char *__restrict,
+			    socklen_t, unsigned int);
+void		freeaddrinfo(struct addrinfo *);
+char		*gai_strerror(int);
+int		setnetgrent(const char *);
+void		setservent(int);
+
+/*
+ * PRIVATE functions specific to the FreeBSD implementation
+ */
+
+/* DO NOT USE THESE, THEY ARE SUBJECT TO CHANGE AND ARE NOT PORTABLE!!! */
+void	_sethosthtent(int);
+void	_sethosthtent_r(int, FILE **, int *);
+void	_endhosthtent(void);
+void	_endhosthtent_r(FILE **, int *);
+void	_sethostdnsent(int);
+void	_endhostdnsent(void);
+void	_setnethtent(int);
+void	_endnethtent(void);
+void	_setnetdnsent(int);
+void	_endnetdnsent(void);
+struct hostent * _gethostbynisname(const char *, int);
+struct hostent * _gethostbynisaddr(const char *, int, int);
+void _map_v4v6_address(const char *, char *);
+void _map_v4v6_hostent(struct hostent *, char **, int *);
+__END_DECLS
+
+#endif /* !_NETDB_H_ */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/netinet/in.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/netinet/in.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/netinet/in.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/netinet/in.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,566 @@
+/*
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)in.h	8.3 (Berkeley) 1/3/94
+ * $FreeBSD: src/sys/netinet/in.h,v 1.68 2002/04/24 01:26:11 mike Exp $
+ */
+
+#ifndef _NETINET_IN_H_
+#define _NETINET_IN_H_
+
+#include <sys/cdefs.h>
+#include <sys/config.h>
+#include <sys/_types.h>
+#include <machine/endian.h>
+
+/* Protocols common to RFC 1700, POSIX, and X/Open. */
+#define	IPPROTO_IP		0		/* dummy for IP */
+#define	IPPROTO_ICMP		1		/* control message protocol */
+#define	IPPROTO_TCP		6		/* tcp */
+#define	IPPROTO_UDP		17		/* user datagram protocol */
+
+#define	INADDR_ANY		(u_int32_t)0x00000000
+#define	INADDR_BROADCAST	(u_int32_t)0xffffffff	/* must be masked */
+
+#ifndef _UINT8_T_DECLARED
+typedef	__uint8_t		uint8_t;
+#define	_UINT8_T_DECLARED
+#endif
+
+#ifndef _UINT16_T_DECLARED
+typedef	__uint16_t		uint16_t;
+#define	_UINT16_T_DECLARED
+#endif
+
+#ifndef _UINT32_T_DECLARED
+typedef	__uint32_t		uint32_t;
+#define	_UINT32_T_DECLARED
+#endif
+
+#ifndef _IN_ADDR_T_DECLARED
+typedef	uint32_t		in_addr_t;
+#define	_IN_ADDR_T_DECLARED
+#endif
+
+#ifndef _IN_PORT_T_DECLARED
+typedef	uint16_t		in_port_t;
+#define	_IN_PORT_T_DECLARED
+#endif
+
+typedef unsigned short sa_family_t;
+
+#ifdef _BSD_SA_FAMILY_T_
+typedef	_BSD_SA_FAMILY_T_	sa_family_t;
+#undef _BSD_SA_FAMILY_T_ 
+#endif
+
+/* Internet address (a structure for historical reasons). */
+#ifndef	_STRUCT_IN_ADDR_DECLARED
+struct in_addr {
+	in_addr_t s_addr;
+};
+#define	_STRUCT_IN_ADDR_DECLARED
+#endif
+
+/* Socket address, internet style. */
+struct sockaddr_in {
+	sa_family_t	sin_family;
+	in_port_t	sin_port;
+	struct	in_addr sin_addr;
+	char	sin_zero[8];
+};
+
+#if __POSIX_VISIBLE >= 200112
+#define	IPPROTO_RAW		255		/* raw IP packet */
+#define	INET_ADDRSTRLEN		16
+#endif
+
+#define __BSD_VISIBLE 1
+#if __BSD_VISIBLE
+/*
+ * Constants and structures defined by the internet system,
+ * Per RFC 790, September 1981, and numerous additions.
+ */
+
+/*
+ * Protocols (RFC 1700)
+ */
+#define	IPPROTO_HOPOPTS		0		/* IP6 hop-by-hop options */
+#define	IPPROTO_IGMP		2		/* group mgmt protocol */
+#define	IPPROTO_GGP		3		/* gateway^2 (deprecated) */
+#define IPPROTO_IPV4		4 		/* IPv4 encapsulation */
+#define IPPROTO_IPIP		IPPROTO_IPV4	/* for compatibility */
+#define	IPPROTO_ST		7		/* Stream protocol II */
+#define	IPPROTO_EGP		8		/* exterior gateway protocol */
+#define	IPPROTO_PIGP		9		/* private interior gateway */
+#define	IPPROTO_RCCMON		10		/* BBN RCC Monitoring */
+#define	IPPROTO_NVPII		11		/* network voice protocol*/
+#define	IPPROTO_PUP		12		/* pup */
+#define	IPPROTO_ARGUS		13		/* Argus */
+#define	IPPROTO_EMCON		14		/* EMCON */
+#define	IPPROTO_XNET		15		/* Cross Net Debugger */
+#define	IPPROTO_CHAOS		16		/* Chaos*/
+#define	IPPROTO_MUX		18		/* Multiplexing */
+#define	IPPROTO_MEAS		19		/* DCN Measurement Subsystems */
+#define	IPPROTO_HMP		20		/* Host Monitoring */
+#define	IPPROTO_PRM		21		/* Packet Radio Measurement */
+#define	IPPROTO_IDP		22		/* xns idp */
+#define	IPPROTO_TRUNK1		23		/* Trunk-1 */
+#define	IPPROTO_TRUNK2		24		/* Trunk-2 */
+#define	IPPROTO_LEAF1		25		/* Leaf-1 */
+#define	IPPROTO_LEAF2		26		/* Leaf-2 */
+#define	IPPROTO_RDP		27		/* Reliable Data */
+#define	IPPROTO_IRTP		28		/* Reliable Transaction */
+#define	IPPROTO_TP		29 		/* tp-4 w/ class negotiation */
+#define	IPPROTO_BLT		30		/* Bulk Data Transfer */
+#define	IPPROTO_NSP		31		/* Network Services */
+#define	IPPROTO_INP		32		/* Merit Internodal */
+#define	IPPROTO_SEP		33		/* Sequential Exchange */
+#define	IPPROTO_3PC		34		/* Third Party Connect */
+#define	IPPROTO_IDPR		35		/* InterDomain Policy Routing */
+#define	IPPROTO_XTP		36		/* XTP */
+#define	IPPROTO_DDP		37		/* Datagram Delivery */
+#define	IPPROTO_CMTP		38		/* Control Message Transport */
+#define	IPPROTO_TPXX		39		/* TP++ Transport */
+#define	IPPROTO_IL		40		/* IL transport protocol */
+#define	IPPROTO_IPV6		41		/* IP6 header */
+#define	IPPROTO_SDRP		42		/* Source Demand Routing */
+#define	IPPROTO_ROUTING		43		/* IP6 routing header */
+#define	IPPROTO_FRAGMENT	44		/* IP6 fragmentation header */
+#define	IPPROTO_IDRP		45		/* InterDomain Routing*/
+#define	IPPROTO_RSVP		46 		/* resource reservation */
+#define	IPPROTO_GRE		47		/* General Routing Encap. */
+#define	IPPROTO_MHRP		48		/* Mobile Host Routing */
+#define	IPPROTO_BHA		49		/* BHA */
+#define	IPPROTO_ESP		50		/* IP6 Encap Sec. Payload */
+#define	IPPROTO_AH		51		/* IP6 Auth Header */
+#define	IPPROTO_INLSP		52		/* Integ. Net Layer Security */
+#define	IPPROTO_SWIPE		53		/* IP with encryption */
+#define	IPPROTO_NHRP		54		/* Next Hop Resolution */
+#define IPPROTO_MOBILE		55		/* IP Mobility */
+#define IPPROTO_TLSP		56		/* Transport Layer Security */
+#define IPPROTO_SKIP		57		/* SKIP */
+#define	IPPROTO_ICMPV6		58		/* ICMP6 */
+#define	IPPROTO_NONE		59		/* IP6 no next header */
+#define	IPPROTO_DSTOPTS		60		/* IP6 destination option */
+#define	IPPROTO_AHIP		61		/* any host internal protocol */
+#define	IPPROTO_CFTP		62		/* CFTP */
+#define	IPPROTO_HELLO		63		/* "hello" routing protocol */
+#define	IPPROTO_SATEXPAK	64		/* SATNET/Backroom EXPAK */
+#define	IPPROTO_KRYPTOLAN	65		/* Kryptolan */
+#define	IPPROTO_RVD		66		/* Remote Virtual Disk */
+#define	IPPROTO_IPPC		67		/* Pluribus Packet Core */
+#define	IPPROTO_ADFS		68		/* Any distributed FS */
+#define	IPPROTO_SATMON		69		/* Satnet Monitoring */
+#define	IPPROTO_VISA		70		/* VISA Protocol */
+#define	IPPROTO_IPCV		71		/* Packet Core Utility */
+#define	IPPROTO_CPNX		72		/* Comp. Prot. Net. Executive */
+#define	IPPROTO_CPHB		73		/* Comp. Prot. HeartBeat */
+#define	IPPROTO_WSN		74		/* Wang Span Network */
+#define	IPPROTO_PVP		75		/* Packet Video Protocol */
+#define	IPPROTO_BRSATMON	76		/* BackRoom SATNET Monitoring */
+#define	IPPROTO_ND		77		/* Sun net disk proto (temp.) */
+#define	IPPROTO_WBMON		78		/* WIDEBAND Monitoring */
+#define	IPPROTO_WBEXPAK		79		/* WIDEBAND EXPAK */
+#define	IPPROTO_EON		80		/* ISO cnlp */
+#define	IPPROTO_VMTP		81		/* VMTP */
+#define	IPPROTO_SVMTP		82		/* Secure VMTP */
+#define	IPPROTO_VINES		83		/* Banyon VINES */
+#define	IPPROTO_TTP		84		/* TTP */
+#define	IPPROTO_IGP		85		/* NSFNET-IGP */
+#define	IPPROTO_DGP		86		/* dissimilar gateway prot. */
+#define	IPPROTO_TCF		87		/* TCF */
+#define	IPPROTO_IGRP		88		/* Cisco/GXS IGRP */
+#define	IPPROTO_OSPFIGP		89		/* OSPFIGP */
+#define	IPPROTO_SRPC		90		/* Strite RPC protocol */
+#define	IPPROTO_LARP		91		/* Locus Address Resoloution */
+#define	IPPROTO_MTP		92		/* Multicast Transport */
+#define	IPPROTO_AX25		93		/* AX.25 Frames */
+#define	IPPROTO_IPEIP		94		/* IP encapsulated in IP */
+#define	IPPROTO_MICP		95		/* Mobile Int.ing control */
+#define	IPPROTO_SCCSP		96		/* Semaphore Comm. security */
+#define	IPPROTO_ETHERIP		97		/* Ethernet IP encapsulation */
+#define	IPPROTO_ENCAP		98		/* encapsulation header */
+#define	IPPROTO_APES		99		/* any private encr. scheme */
+#define	IPPROTO_GMTP		100		/* GMTP*/
+#define	IPPROTO_IPCOMP		108		/* payload compression (IPComp) */
+/* 101-254: Partly Unassigned */
+#define	IPPROTO_PIM		103		/* Protocol Independent Mcast */
+#define	IPPROTO_PGM		113		/* PGM */
+/* 255: Reserved */
+/* BSD Private, local use, namespace incursion */
+#define	IPPROTO_DIVERT		254		/* divert pseudo-protocol */
+#define	IPPROTO_MAX		256
+
+/* last return value of *_input(), meaning "all job for this pkt is done".  */
+#define	IPPROTO_DONE		257
+
+/*
+ * Local port number conventions:
+ *
+ * When a user does a bind(2) or connect(2) with a port number of zero,
+ * a non-conflicting local port address is chosen.
+ * The default range is IPPORT_HIFIRSTAUTO through
+ * IPPORT_HILASTAUTO, although that is settable by sysctl.
+ *
+ * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
+ * default assignment range.
+ *
+ * The value IP_PORTRANGE_DEFAULT causes the default behavior.
+ *
+ * The value IP_PORTRANGE_HIGH changes the range of candidate port numbers
+ * into the "high" range.  These are reserved for client outbound connections
+ * which do not want to be filtered by any firewalls.  Note that by default
+ * this is the same as IP_PORTRANGE_DEFAULT.
+ *
+ * The value IP_PORTRANGE_LOW changes the range to the "low" are
+ * that is (by convention) restricted to privileged processes.  This
+ * convention is based on "vouchsafe" principles only.  It is only secure
+ * if you trust the remote host to restrict these ports.
+ *
+ * The default range of ports and the high range can be changed by
+ * sysctl(3).  (net.inet.ip.port{hi,low}{first,last}_auto)
+ *
+ * Changing those values has bad security implications if you are
+ * using a a stateless firewall that is allowing packets outside of that
+ * range in order to allow transparent outgoing connections.
+ *
+ * Such a firewall configuration will generally depend on the use of these
+ * default values.  If you change them, you may find your Security
+ * Administrator looking for you with a heavy object.
+ *
+ * For a slightly more orthodox text view on this:
+ *
+ *            ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers
+ *
+ *    port numbers are divided into three ranges:
+ *
+ *                0 -  1023 Well Known Ports
+ *             1024 - 49151 Registered Ports
+ *            49152 - 65535 Dynamic and/or Private Ports
+ *
+ */
+
+/*
+ * Ports < IPPORT_RESERVED are reserved for
+ * privileged processes (e.g. root).         (IP_PORTRANGE_LOW)
+ */
+#define	IPPORT_RESERVED		1024
+
+/*
+ * Default local port range, used by both IP_PORTRANGE_DEFAULT
+ * and IP_PORTRANGE_HIGH.
+ */
+#define	IPPORT_HIFIRSTAUTO	49152
+#define	IPPORT_HILASTAUTO	65535
+
+/*
+ * Scanning for a free reserved port return a value below IPPORT_RESERVED,
+ * but higher than IPPORT_RESERVEDSTART.  Traditionally the start value was
+ * 512, but that conflicts with some well-known-services that firewalls may
+ * have a fit if we use.
+ */
+#define IPPORT_RESERVEDSTART	600
+
+#define	IPPORT_MAX		65535
+
+#ifndef _UINT8_T_DECLARED
+typedef	__uint8_t		uint8_t;
+#define	_UINT8_T_DECLARED
+#endif
+
+#ifndef _UINT16_T_DECLARED
+typedef	__uint16_t		uint16_t;
+#define	_UINT16_T_DECLARED
+#endif
+
+#ifndef _UINT32_T_DECLARED
+typedef	__uint32_t		uint32_t;
+#define	_UINT32_T_DECLARED
+#endif
+
+#ifndef _IN_ADDR_T_DECLARED
+typedef	uint32_t		in_addr_t;
+#define	_IN_ADDR_T_DECLARED
+#endif
+
+#ifndef _IN_PORT_T_DECLARED
+typedef	uint16_t		in_port_t;
+#define	_IN_PORT_T_DECLARED
+#endif
+
+#ifdef _BSD_SA_FAMILY_T_
+typedef	_BSD_SA_FAMILY_T_	sa_family_t;
+#undef _BSD_SA_FAMILY_T_
+#endif
+
+/*
+ * Internet address (a structure for historical reasons)
+ */
+#ifndef	_STRUCT_IN_ADDR_DECLARED
+struct in_addr {
+	in_addr_t s_addr;
+};
+#define	_STRUCT_IN_ADDR_DECLARED
+#endif
+
+/*
+ * Definitions of bits in internet address integers.
+ * On subnets, the decomposition of addresses to host and net parts
+ * is done according to subnet mask, not the masks here.
+ */
+#define	IN_CLASSA(i)		(((u_int32_t)(i) & 0x80000000) == 0)
+#define	IN_CLASSA_NET		0xff000000
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		0x00ffffff
+#define	IN_CLASSA_MAX		128
+
+#define	IN_CLASSB(i)		(((u_int32_t)(i) & 0xc0000000) == 0x80000000)
+#define	IN_CLASSB_NET		0xffff0000
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		0x0000ffff
+#define	IN_CLASSB_MAX		65536
+
+#define	IN_CLASSC(i)		(((u_int32_t)(i) & 0xe0000000) == 0xc0000000)
+#define	IN_CLASSC_NET		0xffffff00
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		0x000000ff
+
+#define	IN_CLASSD(i)		(((u_int32_t)(i) & 0xf0000000) == 0xe0000000)
+#define	IN_CLASSD_NET		0xf0000000	/* These ones aren't really */
+#define	IN_CLASSD_NSHIFT	28		/* net and host fields, but */
+#define	IN_CLASSD_HOST		0x0fffffff	/* routing needn't know.    */
+#define	IN_MULTICAST(i)		IN_CLASSD(i)
+
+#define	IN_EXPERIMENTAL(i)	(((u_int32_t)(i) & 0xf0000000) == 0xf0000000)
+#define	IN_BADCLASS(i)		(((u_int32_t)(i) & 0xf0000000) == 0xf0000000)
+
+#define	INADDR_LOOPBACK		(u_int32_t)0x7f000001
+#ifndef _KERNEL
+#define	INADDR_NONE		0xffffffff		/* -1 return */
+#endif
+
+#define	INADDR_UNSPEC_GROUP	(u_int32_t)0xe0000000	/* 224.0.0.0 */
+#define	INADDR_ALLHOSTS_GROUP	(u_int32_t)0xe0000001	/* 224.0.0.1 */
+#define	INADDR_ALLRTRS_GROUP	(u_int32_t)0xe0000002	/* 224.0.0.2 */
+#define	INADDR_MAX_LOCAL_GROUP	(u_int32_t)0xe00000ff	/* 224.0.0.255 */
+
+#define	IN_LOOPBACKNET		127			/* official! */
+
+/*
+ * Options for use with [gs]etsockopt at the IP level.
+ * First word of comment is data type; bool is stored in int.
+ */
+#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
+#define	IP_HDRINCL		2    /* int; header is included with data */
+#define	IP_TOS			3    /* int; IP type of service and preced. */
+#define	IP_TTL			4    /* int; IP time to live */
+#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
+#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
+#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
+#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
+#define	IP_MULTICAST_IF		9    /* u_char; set/get IP multicast i/f  */
+#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
+#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
+#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
+#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
+#define IP_MULTICAST_VIF	14   /* set/get IP mcast virt. iface */
+#define IP_RSVP_ON		15   /* enable RSVP in kernel */
+#define IP_RSVP_OFF		16   /* disable RSVP in kernel */
+#define IP_RSVP_VIF_ON		17   /* set RSVP per-vif socket */
+#define IP_RSVP_VIF_OFF		18   /* unset RSVP per-vif socket */
+#define IP_PORTRANGE		19   /* int; range to choose for unspec port */
+#define	IP_RECVIF		20   /* bool; receive reception if w/dgram */
+/* for IPSEC */
+#define	IP_IPSEC_POLICY		21   /* int; set/get security policy */
+#define	IP_FAITH		22   /* bool; accept FAITH'ed connections */
+
+#define	IP_FW_ADD     		50   /* add a firewall rule to chain */
+#define	IP_FW_DEL    		51   /* delete a firewall rule from chain */
+#define	IP_FW_FLUSH   		52   /* flush firewall rule chain */
+#define	IP_FW_ZERO    		53   /* clear single/all firewall counter(s) */
+#define	IP_FW_GET     		54   /* get entire firewall rule chain */
+#define	IP_FW_RESETLOG		55   /* reset logging counters */
+
+#define	IP_DUMMYNET_CONFIGURE	60   /* add/configure a dummynet pipe */
+#define	IP_DUMMYNET_DEL		61   /* delete a dummynet pipe from chain */
+#define	IP_DUMMYNET_FLUSH	62   /* flush dummynet */
+#define	IP_DUMMYNET_GET		64   /* get entire dummynet pipes */
+
+/*
+ * Defaults and limits for options
+ */
+#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
+#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
+#define	IP_MAX_MEMBERSHIPS	20	/* per socket */
+
+/*
+ * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
+ */
+struct ip_mreq {
+	struct	in_addr imr_multiaddr;	/* IP multicast address of group */
+	struct	in_addr imr_interface;	/* local IP address of interface */
+};
+
+/*
+ * Argument for IP_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define	IP_PORTRANGE_DEFAULT	0	/* default range */
+#define	IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
+#define	IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
+
+/*
+ * Definitions for inet sysctl operations.
+ *
+ * Third level is protocol number.
+ * Fourth level is desired variable within that protocol.
+ */
+#define	IPPROTO_MAXID	(IPPROTO_AH + 1)	/* don't list to IPPROTO_MAX */
+
+#define	CTL_IPPROTO_NAMES { \
+	{ "ip", CTLTYPE_NODE }, \
+	{ "icmp", CTLTYPE_NODE }, \
+	{ "igmp", CTLTYPE_NODE }, \
+	{ "ggp", CTLTYPE_NODE }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ "tcp", CTLTYPE_NODE }, \
+	{ 0, 0 }, \
+	{ "egp", CTLTYPE_NODE }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ "pup", CTLTYPE_NODE }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ "udp", CTLTYPE_NODE }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ "idp", CTLTYPE_NODE }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ "ipsec", CTLTYPE_NODE }, \
+}
+
+/*
+ * Names for IP sysctl objects
+ */
+#define	IPCTL_FORWARDING	1	/* act as router */
+#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
+#define	IPCTL_DEFTTL		3	/* default TTL */
+#ifdef notyet
+#define	IPCTL_DEFMTU		4	/* default MTU */
+#endif
+#define IPCTL_RTEXPIRE		5	/* cloned route expiration time */
+#define IPCTL_RTMINEXPIRE	6	/* min value for expiration time */
+#define IPCTL_RTMAXCACHE	7	/* trigger level for dynamic expire */
+#define	IPCTL_SOURCEROUTE	8	/* may perform source routes */
+#define	IPCTL_DIRECTEDBROADCAST	9	/* may re-broadcast received packets */
+#define IPCTL_INTRQMAXLEN	10	/* max length of netisr queue */
+#define	IPCTL_INTRQDROPS	11	/* number of netisr q drops */
+#define	IPCTL_STATS		12	/* ipstat structure */
+#define	IPCTL_ACCEPTSOURCEROUTE	13	/* may accept source routed packets */
+#define	IPCTL_FASTFORWARDING	14	/* use fast IP forwarding code */
+#define	IPCTL_KEEPFAITH		15	/* FAITH IPv4->IPv6 translater ctl */
+#define	IPCTL_GIF_TTL		16	/* default TTL for gif encap packet */
+#define	IPCTL_MAXID		17
+
+#define	IPCTL_NAMES { \
+	{ 0, 0 }, \
+	{ "forwarding", CTLTYPE_INT }, \
+	{ "redirect", CTLTYPE_INT }, \
+	{ "ttl", CTLTYPE_INT }, \
+	{ "mtu", CTLTYPE_INT }, \
+	{ "rtexpire", CTLTYPE_INT }, \
+	{ "rtminexpire", CTLTYPE_INT }, \
+	{ "rtmaxcache", CTLTYPE_INT }, \
+	{ "sourceroute", CTLTYPE_INT }, \
+ 	{ "directed-broadcast", CTLTYPE_INT }, \
+	{ "intr-queue-maxlen", CTLTYPE_INT }, \
+	{ "intr-queue-drops", CTLTYPE_INT }, \
+	{ "stats", CTLTYPE_STRUCT }, \
+	{ "accept_sourceroute", CTLTYPE_INT }, \
+	{ "fastforwarding", CTLTYPE_INT }, \
+}
+
+#endif /* __BSD_VISIBLE */
+
+#ifdef _KERNEL
+
+struct ifnet; struct mbuf;	/* forward declarations for Standard C */
+
+int	 in_broadcast(struct in_addr, struct ifnet *);
+int	 in_canforward(struct in_addr);
+int	 in_localaddr(struct in_addr);
+char 	*inet_ntoa(struct in_addr); /* in libkern */
+char	*inet_ntoa_r(struct in_addr ina, char *buf); /* in libkern */
+
+#define satosin(sa)	((struct sockaddr_in *)(sa))
+#define sintosa(sin)	((struct sockaddr *)(sin))
+#define ifatoia(ifa)	((struct in_ifaddr *)(ifa))
+
+#endif /* _KERNEL */
+
+/* INET6 stuff
+#define	__KAME_NETINET_IN_H_INCLUDED_
+#include <netinet6/in6.h>
+#undef __KAME_NETINET_IN_H_INCLUDED_
+*/
+
+#endif /* !_NETINET_IN_H_*/
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/paths.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/paths.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/paths.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/paths.h	2025-04-04 11:01:02 +0000
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)paths.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PATHS_H_
+#define	_PATHS_H_
+
+/* Default search path. */
+#define	_PATH_DEFPATH	"/usr/bin:/bin"
+/* All standard utilities path. */
+#define	_PATH_STDPATH \
+	"/usr/bin:/bin:/usr/sbin:/sbin"
+
+#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_CONSOLE	"/dev/console"
+#define	_PATH_CSHELL	"/bin/csh"
+#define	_PATH_DEVDB	"/var/run/dev.db"
+#define	_PATH_DEVNULL	"/dev/null"
+#define	_PATH_DRUM	"/dev/drum"
+#define	_PATH_GSHADOW	"/etc/gshadow"
+#define	_PATH_KMEM	"/dev/kmem"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+#define	_PATH_MAILDIR	"/var/mail"
+#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_MEM	"/dev/mem"
+#define	_PATH_MNTTAB	"/etc/fstab"
+#define	_PATH_MOUNTED	"/etc/mtab"
+#define	_PATH_NOLOGIN	"/etc/nologin"
+#define	_PATH_PRESERVE	"/var/lib"
+#define	_PATH_RWHODIR	"/var/spool/rwho"
+#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
+#define	_PATH_SHADOW	"/etc/shadow"
+#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_TTY	"/dev/tty"
+#define	_PATH_UNIX	"/boot/fiwix"
+#define _PATH_UTMP	"/var/run/utmp"
+#define	_PATH_VI	"/bin/vim"
+#define _PATH_WTMP	"/var/log/wtmp"
+
+/* Provide trailing slash, since mostly used for building pathnames. */
+#define	_PATH_DEV	"/dev/"
+#define	_PATH_TMP	"/tmp/"
+#define	_PATH_VARDB	"/var/db/"
+#define	_PATH_VARRUN	"/var/run/"
+#define	_PATH_VARTMP	"/var/tmp/"
+
+#define _PATH_DEVPTMX	_PATH_DEV "ptmx"
+#define _PATH_DEVPTS	_PATH_DEV "pts"
+
+#endif /* !_PATHS_H_ */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/pty.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/pty.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/pty.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/pty.h	2025-04-12 18:53:28 +0000
@@ -0,0 +1,20 @@
+#ifndef _PTY_H
+#define _PTY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <termios.h>
+#include <sys/ioctl.h>
+
+extern int openpty(int *, int *, char *, const struct termios *, const struct winsize *);
+/*
+extern int forkpty(int *, char *, const struct termios *, const struct winsize *);
+*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _PTY_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/sysexits.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/sysexits.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/include/sysexits.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/include/sysexits.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 1987, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)sysexits.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef	_SYSEXITS_H
+#define	_SYSEXITS_H 1
+
+/*
+ *  SYSEXITS.H -- Exit status codes for system programs.
+ *
+ *	This include file attempts to categorize possible error
+ *	exit statuses for system programs, notably delivermail
+ *	and the Berkeley network.
+ *
+ *	Error numbers begin at EX__BASE to reduce the possibility of
+ *	clashing with other exit statuses that random programs may
+ *	already return.  The meaning of the codes is approximately
+ *	as follows:
+ *
+ *	EX_USAGE -- The command was used incorrectly, e.g., with
+ *		the wrong number of arguments, a bad flag, a bad
+ *		syntax in a parameter, or whatever.
+ *	EX_DATAERR -- The input data was incorrect in some way.
+ *		This should only be used for user's data & not
+ *		system files.
+ *	EX_NOINPUT -- An input file (not a system file) did not
+ *		exist or was not readable.  This could also include
+ *		errors like "No message" to a mailer (if it cared
+ *		to catch it).
+ *	EX_NOUSER -- The user specified did not exist.  This might
+ *		be used for mail addresses or remote logins.
+ *	EX_NOHOST -- The host specified did not exist.  This is used
+ *		in mail addresses or network requests.
+ *	EX_UNAVAILABLE -- A service is unavailable.  This can occur
+ *		if a support program or file does not exist.  This
+ *		can also be used as a catchall message when something
+ *		you wanted to do doesn't work, but you don't know
+ *		why.
+ *	EX_SOFTWARE -- An internal software error has been detected.
+ *		This should be limited to non-operating system related
+ *		errors as possible.
+ *	EX_OSERR -- An operating system error has been detected.
+ *		This is intended to be used for such things as "cannot
+ *		fork", "cannot create pipe", or the like.  It includes
+ *		things like getuid returning a user that does not
+ *		exist in the passwd file.
+ *	EX_OSFILE -- Some system file (e.g., /etc/passwd, /etc/utmp,
+ *		etc.) does not exist, cannot be opened, or has some
+ *		sort of error (e.g., syntax error).
+ *	EX_CANTCREAT -- A (user specified) output file cannot be
+ *		created.
+ *	EX_IOERR -- An error occurred while doing I/O on some file.
+ *	EX_TEMPFAIL -- temporary failure, indicating something that
+ *		is not really an error.  In sendmail, this means
+ *		that a mailer (e.g.) could not create a connection,
+ *		and the request should be reattempted later.
+ *	EX_PROTOCOL -- the remote system returned something that
+ *		was "not possible" during a protocol exchange.
+ *	EX_NOPERM -- You did not have sufficient permission to
+ *		perform the operation.  This is not intended for
+ *		file system problems, which should use NOINPUT or
+ *		CANTCREAT, but rather for higher level permissions.
+ */
+
+#define EX_OK		0	/* successful termination */
+
+#define EX__BASE	64	/* base value for error messages */
+
+#define EX_USAGE	64	/* command line usage error */
+#define EX_DATAERR	65	/* data format error */
+#define EX_NOINPUT	66	/* cannot open input */
+#define EX_NOUSER	67	/* addressee unknown */
+#define EX_NOHOST	68	/* host name unknown */
+#define EX_UNAVAILABLE	69	/* service unavailable */
+#define EX_SOFTWARE	70	/* internal software error */
+#define EX_OSERR	71	/* system error (e.g., can't fork) */
+#define EX_OSFILE	72	/* critical OS file missing */
+#define EX_CANTCREAT	73	/* can't create (user) output file */
+#define EX_IOERR	74	/* input/output error */
+#define EX_TEMPFAIL	75	/* temp failure; user is invited to retry */
+#define EX_PROTOCOL	76	/* remote error in protocol */
+#define EX_NOPERM	77	/* permission denied */
+#define EX_CONFIG	78	/* configuration error */
+
+#define EX__MAX	78	/* maximum listed value */
+
+#endif /* sysexits.h */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/ipc.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/ipc.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/ipc.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/ipc.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,154 @@
+/*
+ * fiwix/ipc.c
+ *
+ * Copyright 2022, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <sys/ipc.h>
+#include <sys/sem.h>
+#include <sys/msg.h>
+#include <sys/shm.h>
+#include "syscalls.h"
+
+/*
+ * The original version of the sys_ipc() system call in Linux 2.0 is:
+ *
+ * sys_ipc(uint call, int arg1, int arg2, int arg3, void *ptr, long arg5)
+ *
+ * That is a total of 6 arguments. Since the Fiwix kernel has a maximum
+ * default number of 5 arguments per system call, we need to pack them
+ * all into an structure to be able to pass them all up:
+ *
+ * struct sysvipc_args {
+ *	int arg1;
+ *	int arg2;
+ *	int arg3;
+ *	void *ptr;
+ *	int arg5;
+ * };
+ */
+
+int ipc(unsigned int, struct sysvipc_args *);
+
+int semop(int semid, struct sembuf *sops, size_t nsops)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = semid;
+	args.ptr = (void *)sops;
+	args.arg2 = nsops;
+
+	return ipc(SEMOP, &args);
+}
+
+int semget(key_t key, int nsems, int semflg)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = key;
+	args.arg2 = nsems;
+	args.arg3 = semflg;
+
+	return ipc(SEMGET, &args);
+}
+
+int semctl(int semid, int semnum, int cmd, void *arg)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = semid;
+	args.arg2 = semnum;
+	args.arg3 = cmd;
+	args.ptr = (void *)arg;
+
+	return ipc(SEMCTL, &args);
+}
+
+int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = msqid;
+	args.arg2 = (int)msgsz;
+	args.arg3 = msgflg;
+	args.ptr = (void *)msgp;
+
+	return ipc(MSGSND, &args);
+}
+
+ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, int msgtyp, int msgflg)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = msqid;
+	args.arg2 = (int)msgsz;
+	args.arg3 = msgtyp;
+	args.ptr = msgp;
+	args.arg5 = msgflg;
+
+	return (ssize_t)ipc(MSGRCV, &args);
+}
+
+int msgget(key_t key, int msgflg)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = key;
+	args.arg2 = msgflg;
+
+	return ipc(MSGGET, &args);
+}
+
+int msgctl(int msqid, int cmd, struct msqid_ds *buf)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = msqid;
+	args.arg2 = cmd;
+	args.ptr = (void *)buf;
+
+	return ipc(MSGCTL, &args);
+}
+
+void *shmat(int shmid, const void *shmaddr, int shmflg)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = shmid;
+	args.ptr = (void *)shmaddr;
+	args.arg2 = shmflg;
+
+	return ipc(SHMAT, &args);
+}
+
+int shmdt(const void *shmaddr)
+{
+	struct sysvipc_args args;
+
+	args.ptr = (void *)shmaddr;
+
+	return ipc(SHMDT, &args);
+}
+
+int shmget(key_t key, size_t size, int shmflg)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = key;
+	args.arg2 = size;
+	args.arg3 = shmflg;
+
+	return ipc(SHMGET, &args);
+}
+
+int shmctl(int shmid, int cmd, struct shmid_ds *buf)
+{
+	struct sysvipc_args args;
+
+	args.arg1 = shmid;
+	args.arg2 = cmd;
+	args.ptr = (void *)buf;
+
+	return ipc(SHMCTL, &args);
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/mntent.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/mntent.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/mntent.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/mntent.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,132 @@
+/*
+ * fiwix/mntent.c
+ *
+ * Copyright 2020, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <mntent.h>
+#include <string.h>
+
+static int split_strtok(char *buf, char *args_space, char *args[])
+{
+	char *token, *copy;
+	char *delimiters;
+	int offset, max_tokens;
+	int n;
+
+	if(!buf) {
+		return 0;
+	}
+
+	max_tokens = 6;
+	offset = n = 0;
+	delimiters = " \t";
+	copy = strdup(buf);
+
+	token = strtok(copy, delimiters);
+
+	if(token) {
+		do {
+			if(args_space) {
+				strcpy(args_space + offset, token);
+				args[n] = args_space + offset;
+				offset += strlen(token) + 1;
+			}
+			n++;
+		} while((token = strtok(NULL, delimiters)) && n < max_tokens);
+	}
+
+	free(copy);
+	return n;
+}
+
+FILE *setmntent(const char *filename, const char *type)
+{
+	return fopen(filename, type);
+}
+
+int endmntent(FILE *stream)
+{
+	fclose(stream);
+	return 1;
+}
+
+struct mntent *getmntent_r(FILE *stream, struct mntent *mntbuf, char *buf, int buflen)
+{
+	char *args[6];
+
+	while(fgets(buf, buflen, stream)) {
+		if(buf[0] == '#') {
+			continue;
+		}
+		if(split_strtok(buf, buf, args) == 6) {
+			mntbuf->mnt_fsname = args[0];
+			mntbuf->mnt_dir = args[1];
+			mntbuf->mnt_type = args[2];
+			mntbuf->mnt_opts = args[3];
+			mntbuf->mnt_freq = atoi(args[4]);
+			mntbuf->mnt_passno = atoi(args[5]);
+			return mntbuf;
+		}
+	}
+
+	return NULL;
+}
+
+struct mntent *getmntent(FILE *stream)
+{
+	static struct mntent mntbuf;
+	static char buffer[4096];
+
+	memset(&mntbuf, 0, sizeof(struct mntent));
+	memset(buffer, 0, sizeof(buffer));
+
+	return getmntent_r(stream, &mntbuf, buffer, sizeof(buffer));
+}
+
+
+/* Copyright (C) 1995-2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Search MNT->mnt_opts for an option matching OPT.
+   Returns the address of the substring, or null if none found.  */
+char *hasmntopt(const struct mntent *mnt, const char *opt)
+{
+  const size_t optlen = strlen (opt);
+  char *rest = mnt->mnt_opts, *p;
+
+  while ((p = strstr (rest, opt)) != NULL)
+    {
+      if (p == rest
+	  || (p[-1] == ','
+	      && (p[optlen] == '\0' ||
+		  p[optlen] == '='  ||
+		  p[optlen] == ',')))
+	return p;
+
+      rest = strchr (rest, ',');
+      if (rest == NULL)
+	break;
+      ++rest;
+    }
+
+  return NULL;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/net_inet_ntoa.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/net_inet_ntoa.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/net_inet_ntoa.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/net_inet_ntoa.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,35 @@
+/* Copyright (c) 2016 Phoenix Systems
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.*/
+
+#include <stdio.h>
+#include <arpa/inet.h>
+
+static char static_buffer[18];
+
+char *inet_ntoa(struct in_addr in)
+{
+	unsigned char *bytes = (unsigned char *) &in;
+	snprintf(static_buffer, sizeof(static_buffer), "%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3]);
+	return static_buffer;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/ptys.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/ptys.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/ptys.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/ptys.c	2025-04-12 17:45:15 +0000
@@ -0,0 +1,127 @@
+/*
+ * fiwix/ptys.c
+ *
+ * Copyright 2025, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+#include <paths.h>
+#include <unistd.h>
+
+/* static buffer for ptsname() */
+static char buffer[sizeof(_PATH_DEVPTS) + 11];	/* enough for a 32bit number */
+
+
+int posix_openpt(int flags)
+{
+	return open(_PATH_DEVPTMX, flags);
+}
+
+/*
+ * Change the ownership and access permission of the slave pseudo-terminal
+ * associated with the master pseudo-terminal specified by 'fd'.
+ */
+int grantpt(int fd)
+{
+	int pty, retval;
+
+	if((retval = ioctl(fd, TIOCGPTN, &pty)) < 0) {
+		return retval;
+	}
+}
+
+/*
+ * Unlock the slave pseudo-terminal associated with the master pseudo-terminal
+ * specified by 'fd'.
+ */
+int unlockpt(int fd)
+{
+	int unlock = 0;
+
+	return ioctl(fd, TIOCSPTLCK, &unlock);
+}
+
+/*
+ * Return the pathname of the pseudo-terminal slave associated with the master
+ * 'fd' is open on, or NULL if there are errors.
+ *
+ * This function is not reentrant; buffer[] will be overwritten by subsequent
+ * calls.
+ */
+char *ptsname(int fd)
+{
+	int pty, len, retval;
+
+	len = sizeof(buffer);
+
+	if((retval = ioctl(fd, TIOCGPTN, &pty)) < 0) {
+		errno = -retval;
+		return NULL;
+	}
+	if(snprintf(buffer, len, "%s/%d", _PATH_DEVPTS, pty) >= len) {
+		errno = ERANGE;
+		return NULL;
+	}
+	return buffer;
+}
+
+/*
+ * Create a pseudo tty master slave pair with 'name' and set terminal
+ * attributes according to 'termp' and 'winp', and return handles for
+ * both ends in 'amaster' and 'aslave'.
+ */
+int openpty(int *amaster, int *aslave, char *name, const struct termios *termp, const struct winsize *winp)
+{
+	int mfd, sfd, retval;
+	char *sname;
+
+	/* open pty master */
+	if((mfd = open("/dev/ptmx", O_RDWR | O_NOCTTY)) < 0) {
+		return mfd;
+	}
+
+	/* grant access to slave pty */
+	if((retval = grantpt(mfd)) < 0) {
+		close(mfd);
+		return retval;
+	}
+
+	/* unlock slave pty */
+	if((retval = unlockpt(mfd)) < 0) {
+		close(mfd);
+		return retval;
+	}
+
+	/* get slave pty name */
+	if(!(sname = ptsname(mfd))) {
+		close(mfd);
+		return -EINVAL;
+	}
+
+	/* open pty slave */
+	if((sfd = open(sname, O_RDWR | O_NOCTTY)) < 0) {
+		close(mfd);
+		return sfd;
+	}
+
+	if(termp) {
+		tcsetattr(sfd, TCSANOW, termp);
+	}
+	if(winp) {
+		ioctl(sfd, TIOCSWINSZ, winp);
+	}
+
+	*amaster = mfd;
+	*aslave = sfd;
+	if(name) {
+		strcpy(name, sname);
+	}
+
+	return 0;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/realpath.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/realpath.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/realpath.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/realpath.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) 2003 Constantin S. Svintsoff <kostik@iclub.nsu.ru>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the authors may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/stat.h>
+#include <sys/unistd.h>
+#include <errno.h>
+#include <limits.h>
+
+/*
+ * Find the real name of path, by removing all ".", ".." and symlink
+ * components.  Returns (resolved) on success, or (NULL) on failure,
+ * in which case the path which caused trouble is left in (resolved).
+ */
+char *
+realpath(const char * __restrict path, char * __restrict resolved)
+{
+	struct stat sb;
+	char *p, *q, *s;
+	size_t left_len, resolved_len;
+	unsigned symlinks;
+	int m, slen;
+	char left[PATH_MAX], next_token[PATH_MAX], symlink[PATH_MAX];
+
+	if (path == NULL) {
+		errno = EINVAL;
+		return (NULL);
+	}
+	if (path[0] == '\0') {
+		errno = ENOENT;
+		return (NULL);
+	}
+	if (resolved == NULL) {
+		resolved = malloc(PATH_MAX);
+		if (resolved == NULL)
+			return (NULL);
+		m = 1;
+	} else
+		m = 0;
+	symlinks = 0;
+	if (path[0] == '/') {
+		resolved[0] = '/';
+		resolved[1] = '\0';
+		if (path[1] == '\0')
+			return (resolved);
+		resolved_len = 1;
+		left_len = strlcpy(left, path + 1, sizeof(left));
+	} else {
+		if (getcwd(resolved, PATH_MAX) == NULL) {
+			if (m)
+				free(resolved);
+			else {
+				resolved[0] = '.';
+				resolved[1] = '\0';
+			}
+			return (NULL);
+		}
+		resolved_len = strlen(resolved);
+		left_len = strlcpy(left, path, sizeof(left));
+	}
+	if (left_len >= sizeof(left) || resolved_len >= PATH_MAX) {
+		if (m)
+			free(resolved);
+		errno = ENAMETOOLONG;
+		return (NULL);
+	}
+
+	/*
+	 * Iterate over path components in `left'.
+	 */
+	while (left_len != 0) {
+		/*
+		 * Extract the next path component and adjust `left'
+		 * and its length.
+		 */
+		p = strchr(left, '/');
+		s = p ? p : left + left_len;
+		if (s - left >= sizeof(next_token)) {
+			if (m)
+				free(resolved);
+			errno = ENAMETOOLONG;
+			return (NULL);
+		}
+		memcpy(next_token, left, s - left);
+		next_token[s - left] = '\0';
+		left_len -= s - left;
+		if (p != NULL)
+			memmove(left, s + 1, left_len + 1);
+		if (resolved[resolved_len - 1] != '/') {
+			if (resolved_len + 1 >= PATH_MAX) {
+				if (m)
+					free(resolved);
+				errno = ENAMETOOLONG;
+				return (NULL);
+			}
+			resolved[resolved_len++] = '/';
+			resolved[resolved_len] = '\0';
+		}
+		if (next_token[0] == '\0') {
+			/*
+			 * Handle consequential slashes.  The path
+			 * before slash shall point to a directory.
+			 *
+			 * Only the trailing slashes are not covered
+			 * by other checks in the loop, but we verify
+			 * the prefix for any (rare) "//" or "/\0"
+			 * occurrence to not implement lookahead.
+			 */
+			if (lstat(resolved, &sb) != 0) {
+				if (m)
+					free(resolved);
+				return (NULL);
+			}
+			if (!S_ISDIR(sb.st_mode)) {
+				if (m)
+					free(resolved);
+				errno = ENOTDIR;
+				return (NULL);
+			}
+			continue;
+		}
+		else if (strcmp(next_token, ".") == 0)
+			continue;
+		else if (strcmp(next_token, "..") == 0) {
+			/*
+			 * Strip the last path component except when we have
+			 * single "/"
+			 */
+			if (resolved_len > 1) {
+				resolved[resolved_len - 1] = '\0';
+				q = strrchr(resolved, '/') + 1;
+				*q = '\0';
+				resolved_len = q - resolved;
+			}
+			continue;
+		}
+
+		/*
+		 * Append the next path component and lstat() it.
+		 */
+		resolved_len = strlcat(resolved, next_token, PATH_MAX);
+		if (resolved_len >= PATH_MAX) {
+			if (m)
+				free(resolved);
+			errno = ENAMETOOLONG;
+			return (NULL);
+		}
+		if (lstat(resolved, &sb) != 0) {
+			if (m)
+				free(resolved);
+			return (NULL);
+		}
+		if (S_ISLNK(sb.st_mode)) {
+			if (symlinks++ > _PC_SYMLINK_MAX) {
+				if (m)
+					free(resolved);
+				errno = ELOOP;
+				return (NULL);
+			}
+			slen = readlink(resolved, symlink, sizeof(symlink) - 1);
+			if (slen < 0) {
+				if (m)
+					free(resolved);
+				return (NULL);
+			}
+			symlink[slen] = '\0';
+			if (symlink[0] == '/') {
+				resolved[1] = 0;
+				resolved_len = 1;
+			} else if (resolved_len > 1) {
+				/* Strip the last path component. */
+				resolved[resolved_len - 1] = '\0';
+				q = strrchr(resolved, '/') + 1;
+				*q = '\0';
+				resolved_len = q - resolved;
+			}
+
+			/*
+			 * If there are any path components left, then
+			 * append them to symlink. The result is placed
+			 * in `left'.
+			 */
+			if (p != NULL) {
+				if (symlink[slen - 1] != '/') {
+					if (slen + 1 >= sizeof(symlink)) {
+						if (m)
+							free(resolved);
+						errno = ENAMETOOLONG;
+						return (NULL);
+					}
+					symlink[slen] = '/';
+					symlink[slen + 1] = 0;
+				}
+				left_len = strlcat(symlink, left,
+				    sizeof(symlink));
+				if (left_len >= sizeof(left)) {
+					if (m)
+						free(resolved);
+					errno = ENAMETOOLONG;
+					return (NULL);
+				}
+			}
+			left_len = strlcpy(left, symlink, sizeof(left));
+		}
+	}
+
+	/*
+	 * Remove trailing slash except when the resolved pathname
+	 * is a single "/".
+	 */
+	if (resolved_len > 1 && resolved[resolved_len - 1] == '/')
+		resolved[resolved_len - 1] = '\0';
+	return (resolved);
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sigwait.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sigwait.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sigwait.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sigwait.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,88 @@
+/* Implementation of sigwait function from POSIX.1c.
+   Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <stddef.h>		/* For NULL.  */
+
+/* This is our dummy signal handler we use here.  */
+static void ignore_signal (int sig);
+
+/* Place where to remember which signal we got.  Please note that this
+   implementation cannot be used for the threaded libc.  The
+   libpthread must provide an own version.  */
+static int was_sig;
+
+static void
+ignore_signal (int sig)
+{
+  /* Remember the signal.  */
+  was_sig = sig;
+}
+
+int
+sigwait (const sigset_t *set, int *sig)
+{
+  sigset_t tmp_mask;
+  struct sigaction saved[NSIG];
+  struct sigaction action;
+  int save_errno;
+  int this;
+
+  /* Prepare set.  */
+  sigfillset (&tmp_mask);
+
+  /* Unblock all signals in the SET and register our nice handler.  */
+  action.sa_handler = ignore_signal;
+  action.sa_flags = 0;
+  sigfillset (&action.sa_mask);	/* Block all signals for handler.  */
+
+  /* Make sure we recognize error conditions by setting WAS_SIG to a
+     value which does not describe a legal signal number.  */
+  was_sig = -1;
+
+  for (this = 1; this < NSIG; ++this)
+    if (sigismember (set, this))
+      {
+	/* Unblock this signal.  */
+	sigdelset (&tmp_mask, this);
+
+	/* Register temporary action handler.  */
+	if (sigaction (this, &action, &saved[this]) != 0)
+	  goto restore_handler;
+      }
+
+  /* Now we can wait for signals.  */
+  sigsuspend (&tmp_mask);
+
+ restore_handler:
+  save_errno = errno;
+
+  while (--this >= 1)
+    if (sigismember (set, this))
+      /* We ignore errors here since we must restore all handlers.  */
+      sigaction (this, &saved[this], NULL);
+
+  errno = (save_errno);
+
+  /* Store the result and return.  */
+  *sig = was_sig;
+  return was_sig == -1 ? -1 : 0;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sockops.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sockops.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sockops.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sockops.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,22 @@
+/* sys_socketcall() subopcodes */
+
+#ifndef _SOCKOPS_H
+#define _SOCKOPS_H
+
+#define SYS_SOCKET	1
+#define SYS_BIND	2
+#define SYS_CONNECT	3
+#define SYS_LISTEN	4
+#define SYS_ACCEPT	5
+#define SYS_GETSOCKNAME	6
+#define SYS_GETPEERNAME	7
+#define SYS_SOCKETPAIR	8
+#define SYS_SEND	9
+#define SYS_RECV	10
+#define SYS_SENDTO	11
+#define SYS_RECVFROM	12
+#define SYS_SHUTDOWN	13
+#define SYS_SETSOCKOPT	14
+#define SYS_GETSOCKOPT	15
+
+#endif /* _SOCKOPS_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/dirent.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/dirent.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/dirent.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/dirent.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,78 @@
+#ifndef _SYS_DIRENT_H
+#define _SYS_DIRENT_H
+
+#include <sys/types.h>
+
+struct dirent {
+	ino_t d_ino;			/* inode number */
+	off_t d_off;			/* offset to next dirent */
+	unsigned short int d_reclen;	/* length of this dirent */
+	char d_name[255 + 1];		/* file name (null-terminated) */
+};
+
+typedef struct {
+    int dd_fd;		/* directory file */
+    int dd_loc;		/* position in buffer */
+    int dd_seek;
+    char *dd_buf;	/* buffer */
+    int dd_len;		/* buffer length */
+    int dd_size;	/* amount of data in buffer */
+} DIR;
+
+#ifdef __LARGE64_FILES
+struct dirent64 {
+	__ino64_t d_ino;		/* inode number */
+	_loff_t d_off;			/* offset to next dirent */
+	unsigned short d_reclen;	/* length of this dirent */
+	unsigned char d_type;		/* file type */
+	char d_name[];			/* file name (null-terminated) */
+};
+
+/*
+ * Fiwix don't supports 'd_type' in dirent structure and it seems
+ * that DT_UNKNOWN forces to have this element.
+ *
+#define DT_UNKNOWN 0
+ */
+
+#define DT_FIFO 1
+#define DT_CHR 2
+#define DT_DIR 4
+#define DT_BLK 6
+#define DT_REG 8
+#define DT_LNK 10
+#define DT_SOCK 12
+#define DT_WHT 14
+
+ssize_t getdents64 (unsigned int, struct dirent64 *, unsigned int);
+#endif /* __LARGE64_FILES */
+
+#define __dirfd(dir) (dir)->dd_fd
+
+/* --- redundant ---
+
+DIR *opendir(const char *);
+struct dirent *readdir(DIR *);
+int readdir_r(DIR *__restrict, struct dirent *__restrict,
+              struct dirent **__restrict);
+void rewinddir(DIR *);
+int closedir(DIR *);
+*/
+
+/* internal prototype */
+void _seekdir(DIR *dir, long offset);
+DIR *_opendir(const char *);
+
+#ifndef _POSIX_SOURCE
+long telldir (DIR *);
+void seekdir (DIR *, off_t loc);
+
+int scandir (const char *__dir,
+             struct dirent ***__namelist,
+             int (*select) (const struct dirent *),
+             int (*compar) (const struct dirent **, const struct dirent **));
+
+int alphasort (const struct dirent **__a, const struct dirent **__b);
+#endif /* _POSIX_SOURCE */
+
+#endif /* _SYS_DIRENT_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/errno.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/errno.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/errno.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/errno.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,34 @@
+#ifndef _SYS_ERRNO_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define _SYS_ERRNO_H
+
+/* --- from newlib's sys/errno.h --- */
+
+#include <sys/reent.h>
+
+#ifndef _REENT_ONLY
+#define errno (*__errno())
+extern int *__errno (void);
+#endif
+
+
+extern __IMPORT const char * const _sys_errlist[];
+extern __IMPORT int _sys_nerr;
+
+#define __errno_r(ptr) ((ptr)->_errno)
+
+/* --------------------------------- */
+
+#define __set_errno(x) (errno = (x))
+
+#include <fiwix/errno.h>
+
+#define ENOTSUP EOPNOTSUPP
+#define EFTYPE		79	/* needed for newlib/libc/search/hash.c */
+
+#ifdef __cplusplus
+}
+#endif
+#endif	/* _SYS_ERRNO_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/fcntl.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/fcntl.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/fcntl.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/fcntl.h	2025-01-31 08:30:24 +0000
@@ -0,0 +1,84 @@
+#ifndef FCNTL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define FCNTL_H
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define FASYNC		 020000	/* fcntl, for BSD compatibility */
+#define O_DIRECT         040000 /* direct disk access hint */
+#define O_LARGEFILE     0100000
+#define O_DIRECTORY     0200000 /* must be a directory */
+#define O_NOFOLLOW      0400000 /* don't follow links */
+#define O_CLOEXEC      02000000	/* set close_on_exec */
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get f_flags */
+#define F_SETFD		2	/* set f_flags */
+#define F_GETFL		3	/* more flags (cloexec) */
+#define F_SETFL		4
+#define F_GETLK		5
+#define F_SETLK		6
+#define F_SETLKW	7
+#define F_DUPFD_CLOEXEC	1030
+
+#define F_SETOWN	8	/*  for sockets. */
+#define F_GETOWN	9	/*  for sockets. */
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+/* operations for bsd flock(), also used by the kernel implementation */
+#define LOCK_SH		1	/* shared lock */
+#define LOCK_EX		2	/* exclusive lock */
+#define LOCK_NB		4	/* or'd with one of the above to prevent
+				   blocking */
+#define LOCK_UN		8	/* remove lock */
+
+/* IEEE Std 1003.1, 2004 Edition */
+struct flock {
+	short int l_type;	/* type of lock: F_RDLCK, F_WRLCK, F_UNLCK */
+	short int l_whence;	/* flag for 'l_start': SEEK_SET, SEEK_CUR, ...*/
+	__off_t l_start;	/* relative offset in bytes */
+	__off_t l_len;		/* size; if 0 then until EOF */
+	__pid_t l_pid;		/* PID holding the lock; returned in F_GETLK */
+};
+
+
+extern int open(const char *, int, ...);
+extern int creat(const char *, mode_t);
+extern int fcntl(int, int, ...);
+extern int flock(int, int);
+
+/* 64bit function for i386 */
+extern int fcntl64(unsigned int, int, unsigned int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* FCNTL_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/features.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/features.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/features.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/features.h	2025-04-05 18:33:46 +0000
@@ -0,0 +1,562 @@
+/*
+ *  Written by Joel Sherrill <joel@OARcorp.com>.
+ *
+ *  COPYRIGHT (c) 1989-2014.
+ *
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  Permission to use, copy, modify, and distribute this software for any
+ *  purpose without fee is hereby granted, provided that this entire notice
+ *  is included in all copies of any software which is or includes a copy
+ *  or modification of this software.
+ *
+ *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+ *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
+ *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
+ *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _SYS_FEATURES_H
+#define _SYS_FEATURES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* 
+ * This file is from Newlib 4.4.0.
+ *
+ * Changes specific for Fiwix:
+ *    - added definition of _POSIX_MONOTONIC_CLOCK.
+ */
+
+#include <_newlib_version.h>
+
+/* Macro to test version of GCC.  Returns 0 for non-GCC or too old GCC. */
+#ifndef __GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define __GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define __GNUC_PREREQ(maj, min) 0
+# endif
+#endif /* __GNUC_PREREQ */
+/* Version with trailing underscores for BSD compatibility. */
+#define	__GNUC_PREREQ__(ma, mi)	__GNUC_PREREQ(ma, mi)
+
+
+/*
+ * Feature test macros control which symbols are exposed by the system
+ * headers.  Any of these must be defined before including any headers.
+ *
+ * __STRICT_ANSI__ (defined by gcc -ansi, -std=c90, -std=c99, or -std=c11)
+ *	ISO C
+ *
+ * _POSIX_SOURCE (deprecated by _POSIX_C_SOURCE=1)
+ * _POSIX_C_SOURCE >= 1
+ * 	POSIX.1-1990
+ *
+ * _POSIX_C_SOURCE >= 2
+ * 	POSIX.2-1992
+ *
+ * _POSIX_C_SOURCE >= 199309L
+ * 	POSIX.1b-1993 Real-time extensions
+ *
+ * _POSIX_C_SOURCE >= 199506L
+ * 	POSIX.1c-1995 Threads extensions
+ *
+ * _POSIX_C_SOURCE >= 200112L
+ * 	POSIX.1-2001 and C99
+ *
+ * _POSIX_C_SOURCE >= 200809L
+ * 	POSIX.1-2008
+ *
+ * _XOPEN_SOURCE
+ *	POSIX.1-1990 and XPG4
+ *
+ * _XOPEN_SOURCE_EXTENDED
+ *	SUSv1 (POSIX.2-1992 plus XPG4v2)
+ *
+ * _XOPEN_SOURCE >= 500
+ *	SUSv2 (POSIX.1c-1995 plus XSI)
+ *
+ * _XOPEN_SOURCE >= 600
+ *	SUSv3 (POSIX.1-2001 plus XSI) and C99
+ *
+ * _XOPEN_SOURCE >= 700
+ *	SUSv4 (POSIX.1-2008 plus XSI)
+ *
+ * _ISOC99_SOURCE or gcc -std=c99 or g++
+ * 	ISO C99
+ *
+ * _ISOC11_SOURCE or gcc -std=c11 or g++ -std=c++11
+ * 	ISO C11
+ *
+ * _ISOC2x_SOURCE or gcc -std=c2x or g++ -std=c++20
+ * 	ISO C11
+ *
+ * _ATFILE_SOURCE (implied by _POSIX_C_SOURCE >= 200809L)
+ *	"at" functions
+ *
+ * _LARGEFILE_SOURCE (deprecated by _XOPEN_SOURCE >= 500)
+ *	fseeko, ftello
+ *
+ * _GNU_SOURCE
+ * 	All of the above plus GNU extensions
+ *
+ * _BSD_SOURCE (deprecated by _DEFAULT_SOURCE)
+ * _SVID_SOURCE (deprecated by _DEFAULT_SOURCE)
+ * _DEFAULT_SOURCE (or none of the above)
+ * 	POSIX-1.2008 with BSD and SVr4 extensions
+ *
+ * _FORTIFY_SOURCE = 1 or 2
+ * 	Object Size Checking function wrappers
+ */
+
+#ifdef _GNU_SOURCE
+#undef _ATFILE_SOURCE
+#define	_ATFILE_SOURCE		1
+#undef	_DEFAULT_SOURCE
+#define	_DEFAULT_SOURCE		1
+#undef _ISOC99_SOURCE
+#define	_ISOC99_SOURCE		1
+#undef _ISOC11_SOURCE
+#define	_ISOC11_SOURCE		1
+#undef _ISOC2X_SOURCE
+#define	_ISOC2X_SOURCE		1
+#undef _POSIX_SOURCE
+#define	_POSIX_SOURCE		1
+#undef _POSIX_C_SOURCE
+#define	_POSIX_C_SOURCE		200809L
+#undef _XOPEN_SOURCE
+#define	_XOPEN_SOURCE		700
+#undef _XOPEN_SOURCE_EXTENDED
+#define	_XOPEN_SOURCE_EXTENDED	1
+#endif /* _GNU_SOURCE */
+
+#if defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || \
+   (!defined(__STRICT_ANSI__) && !defined(_ANSI_SOURCE) && \
+   !defined(_ISOC99_SOURCE) && !defined(_POSIX_SOURCE) && \
+   !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE))
+#undef _DEFAULT_SOURCE
+#define	_DEFAULT_SOURCE		1
+#endif
+
+#if defined(_DEFAULT_SOURCE)
+#undef _POSIX_SOURCE
+#define	_POSIX_SOURCE		1
+#undef _POSIX_C_SOURCE
+#define	_POSIX_C_SOURCE		200809L
+#endif
+
+#if !defined(_POSIX_SOURCE) && !defined(_POSIX_C_SOURCE) && \
+  ((!defined(__STRICT_ANSI__) && !defined(_ANSI_SOURCE)) || \
+   (_XOPEN_SOURCE - 0) >= 500)
+#define	_POSIX_SOURCE		1
+#if !defined(_XOPEN_SOURCE) || (_XOPEN_SOURCE - 0) >= 700
+#define	_POSIX_C_SOURCE		200809L
+#elif (_XOPEN_SOURCE - 0) >= 600
+#define	_POSIX_C_SOURCE		200112L
+#elif (_XOPEN_SOURCE - 0) >= 500
+#define	_POSIX_C_SOURCE		199506L
+#elif (_XOPEN_SOURCE - 0) < 500
+#define	_POSIX_C_SOURCE		2
+#endif
+#endif
+
+#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200809
+#undef _ATFILE_SOURCE
+#define	_ATFILE_SOURCE		1
+#endif
+
+/*
+ * The following private macros are used throughout the headers to control
+ * which symbols should be exposed.  They are for internal use only, as
+ * indicated by the leading double underscore, and must never be used outside
+ * of these headers.
+ *
+ * __POSIX_VISIBLE
+ * 	any version of POSIX.1; enabled by default, or with _POSIX_SOURCE,
+ * 	any value of _POSIX_C_SOURCE, or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 2
+ * 	POSIX.2-1992; enabled by default, with _POSIX_C_SOURCE >= 2,
+ * 	or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 199309
+ * 	POSIX.1b-1993; enabled by default, with _POSIX_C_SOURCE >= 199309L,
+ * 	or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 199506
+ * 	POSIX.1c-1995; enabled by default, with _POSIX_C_SOURCE >= 199506L,
+ * 	or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 200112
+ * 	POSIX.1-2001; enabled by default, with _POSIX_C_SOURCE >= 200112L,
+ * 	or _XOPEN_SOURCE >= 600.
+ *
+ * __POSIX_VISIBLE >= 200809
+ * 	POSIX.1-2008; enabled by default, with _POSIX_C_SOURCE >= 200809L,
+ * 	or _XOPEN_SOURCE >= 700.
+ *
+ * __XSI_VISIBLE
+ *	XPG4 XSI extensions; enabled with any version of _XOPEN_SOURCE.
+ *
+ * __XSI_VISIBLE >= 4
+ *	SUSv1 XSI extensions; enabled with both _XOPEN_SOURCE and
+ * 	_XOPEN_SOURCE_EXTENDED together.
+ *
+ * __XSI_VISIBLE >= 500
+ *	SUSv2 XSI extensions; enabled with _XOPEN_SOURCE >= 500.
+ *
+ * __XSI_VISIBLE >= 600
+ *	SUSv3 XSI extensions; enabled with _XOPEN_SOURCE >= 600.
+ *
+ * __XSI_VISIBLE >= 700
+ *	SUSv4 XSI extensions; enabled with _XOPEN_SOURCE >= 700.
+ *
+ * __ISO_C_VISIBLE >= 1999
+ * 	ISO C99; enabled with gcc -std=c99 or newer (on by default since GCC 5),
+ * 	any version of C++, or with _ISOC99_SOURCE, _POSIX_C_SOURCE >= 200112L,
+ * 	or _XOPEN_SOURCE >= 600.
+ *
+ * __ISO_C_VISIBLE >= 2011
+ * 	ISO C11; enabled with gcc -std=c11 or newer (on by default since GCC 5),
+ * 	g++ -std=c++11 or newer (on by default since GCC 6), or with
+ * 	_ISOC11_SOURCE.
+ *
+ * __ISO_C_VISIBLE >= 2020
+ * 	ISO C2x; enabled with gcc -std=c2x or newer,
+ * 	g++ -std=c++20 or newer, or with
+ * 	_ISOC2X_SOURCE.
+ *
+ * __ATFILE_VISIBLE
+ *	"at" functions; enabled by default, with _ATFILE_SOURCE,
+ * 	_POSIX_C_SOURCE >= 200809L, or _XOPEN_SOURCE >= 700.
+ *
+ * __LARGEFILE_VISIBLE
+ *	fseeko, ftello; enabled with _LARGEFILE_SOURCE or _XOPEN_SOURCE >= 500.
+ *
+ * __BSD_VISIBLE
+ * 	BSD extensions; enabled by default, or with _BSD_SOURCE.
+ *
+ * __SVID_VISIBLE
+ * 	SVr4 extensions; enabled by default, or with _SVID_SOURCE.
+ *
+ * __MISC_VISIBLE
+ * 	Extensions found in both BSD and SVr4 (shorthand for
+ * 	(__BSD_VISIBLE || __SVID_VISIBLE)), or newlib-specific
+ * 	extensions; enabled by default.
+ *
+ * __GNU_VISIBLE
+ * 	GNU extensions; enabled with _GNU_SOURCE.
+ *
+ * __SSP_FORTIFY_LEVEL
+ * 	Object Size Checking; defined to 0 (off), 1, or 2.
+ *
+ * In all cases above, "enabled by default" means either by defining
+ * _DEFAULT_SOURCE, or by not defining any of the public feature test macros.
+ */
+
+#ifdef _ATFILE_SOURCE
+#define	__ATFILE_VISIBLE	1
+#else
+#define	__ATFILE_VISIBLE	0
+#endif
+
+#ifdef _DEFAULT_SOURCE
+#define	__BSD_VISIBLE		1
+#else
+#define	__BSD_VISIBLE		0
+#endif
+
+#ifdef _GNU_SOURCE
+#define	__GNU_VISIBLE		1
+#else
+#define	__GNU_VISIBLE		0
+#endif
+
+#if defined(_ISOC2X_SOURCE) || \
+  (__STDC_VERSION__ - 0) > 201710L || (__cplusplus - 0) >= 202002L
+#define __ISO_C_VISIBLE		2020
+#elif defined(_ISOC11_SOURCE) || \
+  (__STDC_VERSION__ - 0) >= 201112L || (__cplusplus - 0) >= 201103L
+#define	__ISO_C_VISIBLE		2011
+#elif defined(_ISOC99_SOURCE) || (_POSIX_C_SOURCE - 0) >= 200112L || \
+  (__STDC_VERSION__ - 0) >= 199901L || defined(__cplusplus)
+#define	__ISO_C_VISIBLE		1999
+#else
+#define	__ISO_C_VISIBLE		1990
+#endif
+
+#if defined(_LARGEFILE_SOURCE) || (_XOPEN_SOURCE - 0) >= 500
+#define	__LARGEFILE_VISIBLE	1
+#else
+#define	__LARGEFILE_VISIBLE	0
+#endif
+
+#ifdef _DEFAULT_SOURCE
+#define	__MISC_VISIBLE		1
+#else
+#define	__MISC_VISIBLE		0
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 200809L
+#define	__POSIX_VISIBLE		200809
+#elif (_POSIX_C_SOURCE - 0) >= 200112L
+#define	__POSIX_VISIBLE		200112
+#elif (_POSIX_C_SOURCE - 0) >= 199506L
+#define	__POSIX_VISIBLE		199506
+#elif (_POSIX_C_SOURCE - 0) >= 199309L
+#define	__POSIX_VISIBLE		199309
+#elif (_POSIX_C_SOURCE - 0) >= 2 || defined(_XOPEN_SOURCE)
+#define	__POSIX_VISIBLE		199209
+#elif defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE)
+#define	__POSIX_VISIBLE		199009
+#else
+#define	__POSIX_VISIBLE		0
+#endif
+
+#ifdef _DEFAULT_SOURCE
+#define	__SVID_VISIBLE		1
+#else
+#define	__SVID_VISIBLE		0
+#endif
+
+#if (_XOPEN_SOURCE - 0) >= 700
+#define	__XSI_VISIBLE		700
+#elif (_XOPEN_SOURCE - 0) >= 600
+#define	__XSI_VISIBLE		600
+#elif (_XOPEN_SOURCE - 0) >= 500
+#define	__XSI_VISIBLE		500
+#elif defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)
+#define	__XSI_VISIBLE		4
+#elif defined(_XOPEN_SOURCE)
+#define	__XSI_VISIBLE		1
+#else
+#define	__XSI_VISIBLE		0
+#endif
+
+#if _FORTIFY_SOURCE > 0 && !defined(__cplusplus) && !defined(__lint__) && \
+   (__OPTIMIZE__ > 0 || defined(__clang__)) && __GNUC_PREREQ__(4, 1) && \
+   !defined(_LIBC)
+#  if _FORTIFY_SOURCE > 1
+#    define __SSP_FORTIFY_LEVEL 2
+#  else
+#    define __SSP_FORTIFY_LEVEL 1
+#  endif
+#else
+#  define __SSP_FORTIFY_LEVEL 0
+#endif
+
+#ifdef __fiwix__
+#define _POSIX_MONOTONIC_CLOCK		200112L
+#endif
+
+/* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  */
+
+#ifdef __rtems__
+#define _POSIX_JOB_CONTROL     		1
+#define _POSIX_SAVED_IDS       		1
+#define _POSIX_VERSION			199309L
+#define _POSIX_ASYNCHRONOUS_IO		1
+#define _POSIX_FSYNC			1
+#define _POSIX_MAPPED_FILES		1
+#define _POSIX_MEMLOCK			1
+#define _POSIX_MEMLOCK_RANGE		1
+#define _POSIX_MEMORY_PROTECTION	1
+#define _POSIX_MESSAGE_PASSING		1
+#define _POSIX_MONOTONIC_CLOCK		200112L
+#define _POSIX_CLOCK_SELECTION		200112L
+#define _POSIX_PRIORITIZED_IO		1
+#define _POSIX_PRIORITY_SCHEDULING	1
+#define _POSIX_REALTIME_SIGNALS		1
+#define _POSIX_SEMAPHORES		1
+#define _POSIX_SHARED_MEMORY_OBJECTS	1
+#define _POSIX_SYNCHRONIZED_IO		1
+#define _POSIX_TIMERS			1
+#define _POSIX_BARRIERS                 200112L
+#define _POSIX_READER_WRITER_LOCKS      200112L
+#define _POSIX_SPIN_LOCKS               200112L
+
+
+/* In P1003.1b but defined by drafts at least as early as P1003.1c/D10  */
+#define _POSIX_THREADS				1
+#define _POSIX_THREAD_ATTR_STACKADDR		1
+#define _POSIX_THREAD_ATTR_STACKSIZE		1
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	1
+#define _POSIX_THREAD_PRIO_INHERIT		1
+#define _POSIX_THREAD_PRIO_PROTECT		1
+#define _POSIX_THREAD_PROCESS_SHARED		1
+#define _POSIX_THREAD_SAFE_FUNCTIONS		1
+
+/* P1003.4b/D8 defines the constants below this comment. */
+#define _POSIX_SPAWN				1
+#define _POSIX_TIMEOUTS				1
+#define _POSIX_CPUTIME				1
+#define _POSIX_THREAD_CPUTIME			1
+#define _POSIX_SPORADIC_SERVER			1
+#define _POSIX_THREAD_SPORADIC_SERVER		1
+#define _POSIX_DEVICE_CONTROL			1
+#define _POSIX_DEVCTL_DIRECTION			1
+#define _POSIX_INTERRUPT_CONTROL		1
+#define _POSIX_ADVISORY_INFO			1
+
+/* UNIX98 added some new pthread mutex attributes */
+#define _UNIX98_THREAD_MUTEX_ATTRIBUTES         1
+
+/* POSIX 1003.26-2003 defined device control method */
+#define _POSIX_26_VERSION			200312L
+
+#endif
+
+/* XMK loosely adheres to POSIX -- 1003.1 */
+#ifdef __XMK__
+#define _POSIX_THREADS				1
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	1
+#endif
+
+
+#ifdef __svr4__
+# define _POSIX_JOB_CONTROL     1
+# define _POSIX_SAVED_IDS       1
+# define _POSIX_VERSION 199009L
+#endif
+
+#ifdef __CYGWIN__
+
+#if __POSIX_VISIBLE >= 200809
+#define _POSIX_VERSION				200809L
+#define _POSIX2_VERSION				200809L
+#elif __POSIX_VISIBLE >= 200112
+#define _POSIX_VERSION				200112L
+#define _POSIX2_VERSION				200112L
+#elif __POSIX_VISIBLE >= 199506
+#define _POSIX_VERSION				199506L
+#define _POSIX2_VERSION				199506L
+#elif __POSIX_VISIBLE >= 199309
+#define _POSIX_VERSION				199309L
+#define _POSIX2_VERSION				199209L
+#elif __POSIX_VISIBLE >= 199209
+#define _POSIX_VERSION				199009L
+#define _POSIX2_VERSION				199209L
+#elif __POSIX_VISIBLE
+#define _POSIX_VERSION				199009L
+#endif
+#if __XSI_VISIBLE >= 4
+#define _XOPEN_VERSION				__XSI_VISIBLE
+#endif
+
+#define _POSIX_ADVISORY_INFO			200809L
+#define _POSIX_ASYNCHRONOUS_IO			200809L
+#define _POSIX_BARRIERS				200809L
+#define _POSIX_CHOWN_RESTRICTED			     1
+#define _POSIX_CLOCK_SELECTION			200809L
+#define _POSIX_CPUTIME				200809L
+#define _POSIX_FSYNC				200809L
+#define _POSIX_IPV6				200809L
+#define _POSIX_JOB_CONTROL			     1
+#define _POSIX_MAPPED_FILES			200809L
+/* #define _POSIX_MEMLOCK			    -1 */
+#define _POSIX_MEMLOCK_RANGE			200809L
+#define _POSIX_MEMORY_PROTECTION		200809L
+#define _POSIX_MESSAGE_PASSING			200809L
+#define _POSIX_MONOTONIC_CLOCK			200809L
+#define _POSIX_NO_TRUNC				     1
+/* #define _POSIX_PRIORITIZED_IO		    -1 */
+#define _POSIX_PRIORITY_SCHEDULING		200809L
+#define _POSIX_RAW_SOCKETS			200809L
+#define _POSIX_READER_WRITER_LOCKS		200809L
+#define _POSIX_REALTIME_SIGNALS			200809L
+#define _POSIX_REGEXP				     1
+#define _POSIX_SAVED_IDS			     1
+#define _POSIX_SEMAPHORES			200809L
+#define _POSIX_SHARED_MEMORY_OBJECTS		200809L
+#define _POSIX_SHELL				     1
+#define _POSIX_SPAWN				200809L
+#define _POSIX_SPIN_LOCKS			200809L
+/* #define _POSIX_SPORADIC_SERVER		    -1 */
+#define _POSIX_SYNCHRONIZED_IO			200809L
+#define _POSIX_THREAD_ATTR_STACKADDR		200809L
+#define _POSIX_THREAD_ATTR_STACKSIZE		200809L
+#define _POSIX_THREAD_CPUTIME			200809L
+/* #define _POSIX_THREAD_PRIO_INHERIT		    -1 */
+/* #define _POSIX_THREAD_PRIO_PROTECT		    -1 */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
+#define _POSIX_THREAD_PROCESS_SHARED		200809L
+#define _POSIX_THREAD_SAFE_FUNCTIONS		200809L
+/* #define _POSIX_THREAD_SPORADIC_SERVER	    -1 */
+#define _POSIX_THREADS				200809L
+#define _POSIX_TIMEOUTS				200809L
+#define _POSIX_TIMERS				200809L
+/* #define _POSIX_TRACE				    -1 */
+/* #define _POSIX_TRACE_EVENT_FILTER		    -1 */
+/* #define _POSIX_TRACE_INHERIT			    -1 */
+/* #define _POSIX_TRACE_LOG			    -1 */
+/* #define _POSIX_TYPED_MEMORY_OBJECTS		    -1 */
+#define _POSIX_VDISABLE				   '\0'
+
+#if __POSIX_VISIBLE >= 2
+#define _POSIX2_C_VERSION			_POSIX2_VERSION
+#define _POSIX2_C_BIND				_POSIX2_VERSION
+#define _POSIX2_C_DEV				_POSIX2_VERSION
+#define _POSIX2_CHAR_TERM			_POSIX2_VERSION
+/* #define _POSIX2_FORT_DEV			    -1 */
+/* #define _POSIX2_FORT_RUN			    -1 */
+/* #define _POSIX2_LOCALEDEF			    -1 */
+/* #define _POSIX2_PBS				    -1 */
+/* #define _POSIX2_PBS_ACCOUNTING		    -1 */
+/* #define _POSIX2_PBS_CHECKPOINT		    -1 */
+/* #define _POSIX2_PBS_LOCATE			    -1 */
+/* #define _POSIX2_PBS_MESSAGE			    -1 */
+/* #define _POSIX2_PBS_TRACK			    -1 */
+#define _POSIX2_SW_DEV				_POSIX2_VERSION
+#define _POSIX2_UPE				_POSIX2_VERSION
+#endif /* __POSIX_VISIBLE >= 2 */
+
+#define _POSIX_V6_ILP32_OFF32			    -1
+#ifdef __LP64__
+#define _POSIX_V6_ILP32_OFFBIG			    -1
+#define _POSIX_V6_LP64_OFF64			     1
+#define _POSIX_V6_LPBIG_OFFBIG			     1
+#else
+#define _POSIX_V6_ILP32_OFFBIG			     1
+#define _POSIX_V6_LP64_OFF64			    -1
+#define _POSIX_V6_LPBIG_OFFBIG			    -1
+#endif
+#define _POSIX_V7_ILP32_OFF32			_POSIX_V6_ILP32_OFF32
+#define _POSIX_V7_ILP32_OFFBIG			_POSIX_V6_ILP32_OFFBIG
+#define _POSIX_V7_LP64_OFF64			_POSIX_V6_LP64_OFF64
+#define _POSIX_V7_LPBIG_OFFBIG			_POSIX_V6_LPBIG_OFFBIG
+#define _XBS5_ILP32_OFF32			_POSIX_V6_ILP32_OFF32
+#define _XBS5_ILP32_OFFBIG			_POSIX_V6_ILP32_OFFBIG
+#define _XBS5_LP64_OFF64			_POSIX_V6_LP64_OFF64
+#define _XBS5_LPBIG_OFFBIG			_POSIX_V6_LPBIG_OFFBIG
+
+#if __XSI_VISIBLE
+#define _XOPEN_CRYPT				     1
+#define _XOPEN_ENH_I18N				     1
+/* #define _XOPEN_LEGACY			    -1 */
+/* #define _XOPEN_REALTIME			    -1 */
+/* #define _XOPEN_REALTIME_THREADS		    -1 */
+#define _XOPEN_SHM				     1
+/* #define _XOPEN_STREAMS			    -1 */
+/* #define _XOPEN_UNIX				    -1 */
+#endif /* __XSI_VISIBLE */
+
+/*
+ * newlib's wide char conversion functions were updated on
+ *	2019-01-12
+ * to UNICODE version:
+ *	11.0.0 released 2018-06-05
+ */
+#define __STDC_ISO_10646__ 201806L
+
+#endif /* __CYGWIN__ */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_FEATURES_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/io.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/io.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/io.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/io.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,183 @@
+/* Copyright (C) 1996-2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.
+
+   Portability note: not all Linux platforms support this call.  Most
+   platforms based on the PC I/O architecture probably will, however.
+   E.g., Linux/Alpha for Alpha PCs supports this.  */
+extern int ioperm (unsigned int __from, unsigned int __num,
+                   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int __port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int __port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int __port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (__port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int __port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int __port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (__port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int __port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char __value, unsigned short int __port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
+}
+
+static __inline void
+outb_p (unsigned char __value, unsigned short int __port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (__value),
+			"Nd" (__port));
+}
+
+static __inline void
+outw (unsigned short int __value, unsigned short int __port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (__value), "Nd" (__port));
+
+}
+
+static __inline void
+outw_p (unsigned short int __value, unsigned short int __port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (__value),
+			"Nd" (__port));
+}
+
+static __inline void
+outl (unsigned int __value, unsigned short int __port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (__value), "Nd" (__port));
+}
+
+static __inline void
+outl_p (unsigned int __value, unsigned short int __port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (__value),
+			"Nd" (__port));
+}
+
+static __inline void
+insb (unsigned short int __port, void *__addr, unsigned int __count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (__addr), "=c" (__count)
+			:"d" (__port), "0" (__addr), "1" (__count));
+}
+
+static __inline void
+insw (unsigned short int __port, void *__addr, unsigned int __count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (__addr), "=c" (__count)
+			:"d" (__port), "0" (__addr), "1" (__count));
+}
+
+static __inline void
+insl (unsigned short int __port, void *__addr, unsigned int __count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (__addr), "=c" (__count)
+			:"d" (__port), "0" (__addr), "1" (__count));
+}
+
+static __inline void
+outsb (unsigned short int __port, const void *__addr,
+       unsigned int __count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (__addr), "=c" (__count)
+			:"d" (__port), "0" (__addr), "1" (__count));
+}
+
+static __inline void
+outsw (unsigned short int __port, const void *__addr,
+       unsigned int __count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (__addr), "=c" (__count)
+			:"d" (__port), "0" (__addr), "1" (__count));
+}
+
+static __inline void
+outsl (unsigned short int __port, const void *__addr,
+       unsigned int __count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (__addr), "=c" (__count)
+			:"d" (__port), "0" (__addr), "1" (__count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ioctl-i386.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ioctl-i386.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ioctl-i386.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ioctl-i386.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,75 @@
+/* $Id: ioctl.h,v 1.5 1993/07/19 21:53:50 root Exp root $
+ *
+ * linux/ioctl.h for Linux by H.H. Bergman.
+ */
+
+#ifndef _ASMI386_IOCTL_H
+#define _ASMI386_IOCTL_H
+
+/* ioctl command encoding: 32 bits total, command in lower 16 bits,
+ * size of the parameter structure in the lower 14 bits of the
+ * upper 16 bits.
+ * Encoding the size of the parameter structure in the ioctl request
+ * is useful for catching programs compiled with old versions
+ * and to avoid overwriting user space outside the user buffer area.
+ * The highest 2 bits are reserved for indicating the ``access mode''.
+ * NOTE: This limits the max parameter size to 16kB -1 !
+ */
+
+/*
+ * The following is for compatibility across the various Linux
+ * platforms.  The i386 ioctl numbering scheme doesn't really enforce
+ * a type field.  De facto, however, the top 8 bits of the lower 16
+ * bits are indeed used as a type field, so we might just as well make
+ * this explicit here.  Please be sure to use the decoding macros
+ * below from now on.
+ */
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+#define _IOC_SIZEBITS	14
+#define _IOC_DIRBITS	2
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits.
+ */
+#define _IOC_NONE	0U
+#define _IOC_WRITE	1U
+#define _IOC_READ	2U
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+/* used to create numbers */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASMI386_IOCTL_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ioctl.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ioctl.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ioctl.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ioctl.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,104 @@
+#ifndef IOCTL_H
+#define IOCTL_H
+
+#include <sys/ioctl-i386.h>
+
+#define HDIO_GETGEO	0x0301		/* get device geometry */
+
+#define BLKRRPART	0x125F		/* re-read partition table */
+#define BLKGETSIZE	0x1260		/* return device size */
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405		/* get attributes */
+#define TCSETA		0x5406		/* set attributes */
+#define TCSETAW		0x5407		/* drain output only and set state */
+#define TCSETAF		0x5408		/* drain I/O and set state */
+#define TCSBRK		0x5409		/* drain output and send break */
+#define TCXONC		0x540A		/* set flow control */
+#define TCFLSH		0x540B		/* flush I/O */
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413		/* get window size */
+#define TIOCSWINSZ	0x5414		/* set window size */
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCTTYGSTRUCT	0x5426  /* For debugging only */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450  /* these numbers need to be adjusted. */
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458	/* For debugging only */
+#define TIOCSERGETLSR   0x5459	/* Get line status register */
+#define TIOCSERGETMULTI 0x545A	/* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B	/* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define TIOCGHAYESESP   0x545E  /* Get Hayes ESP configuration */
+#define TIOCSHAYESESP   0x545F  /* Set Hayes ESP configuration */
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+
+struct winsize {
+	unsigned short int ws_row;
+	unsigned short int ws_col;
+	unsigned short int ws_xpixel;
+	unsigned short int ws_ypixel;
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int ioctl(int fd, int request, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* IOCTL_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ipc.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ipc.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ipc.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ipc.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,40 @@
+#ifndef _SYS_IPC_H
+#define _SYS_IPC_H
+
+#include <sys/types.h>
+
+#define IPC_CREAT	01000		/* create if key doesn't exist */
+#define IPC_EXCL	02000		/* fail if key exists */
+#define IPC_NOWAIT	04000		/* return error on wait */
+
+#define IPC_PRIVATE	((key_t)0)	/* private key */
+
+#define IPC_RMID	0		/* remove identifier */
+#define IPC_SET		1		/* set options */
+#define IPC_STAT	2		/* get options */
+#define IPC_INFO	3		/* get system-wide limits */
+
+#define SEMOP		1
+#define SEMGET		2
+#define SEMCTL		3
+#define MSGSND		11
+#define MSGRCV		12
+#define MSGGET		13
+#define MSGCTL		14
+#define SHMAT		21
+#define SHMDT		22
+#define SHMGET		23
+#define SHMCTL		24
+
+/* IPC data structure */
+struct ipc_perm {
+	key_t key;			/* key */
+	__uid_t uid;			/* effective UID of owner */
+	__gid_t gid;			/* effective UID of owner */
+	__uid_t cuid;			/* effective UID of creator */
+	__gid_t cgid;			/* effective UID of creator */
+	unsigned short int mode;	/* access modes */
+	unsigned short int seq;		/* slot sequence number */
+};
+
+#endif /* _SYS_IPC_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/kd.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/kd.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/kd.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/kd.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,166 @@
+#ifndef _LINUX_KD_H
+#define _LINUX_KD_H
+
+/* Prefix 0x4B is 'K', to avoid collision with termios and vt */
+
+#define GIO_FONT	0x4B60	/* gets font in expanded form */
+#define PIO_FONT	0x4B61	/* use font in expanded form */
+
+#define GIO_FONTX	0x4B6B	/* get font using struct consolefontdesc */
+#define PIO_FONTX	0x4B6C	/* set font using struct consolefontdesc */
+struct consolefontdesc {
+	unsigned short int charcount;	/* characters in font (256 or 512) */
+	unsigned short int charheight;	/* scan lines per character (1-32) */
+	char *chardata;			/* font data in expanded form */
+};
+
+#define PIO_FONTRESET   0x4B6D	/* reset to default font */
+
+#define GIO_CMAP	0x4B70	/* gets colour palette on VGA+ */
+#define PIO_CMAP	0x4B71	/* sets colour palette on VGA+ */
+
+#define KIOCSOUND	0x4B2F	/* start sound generation (0 for off) */
+#define KDMKTONE	0x4B30	/* generate tone */
+
+#define KDGETLED	0x4B31	/* return current led state */
+#define KDSETLED	0x4B32	/* set led state [lights, not flags] */
+#define LED_SCR		0x01	/* scroll lock led */
+#define LED_NUM		0x02	/* num lock led */
+#define LED_CAP		0x04	/* caps lock led */
+
+#define KDGKBTYPE	0x4B33	/* get keyboard type */
+#define KB_84		0x01
+#define KB_101		0x02 	/* this is what we always answer */
+#define KB_OTHER	0x03
+
+#define KDADDIO		0x4B34	/* add i/o port as valid */
+#define KDDELIO		0x4B35	/* del i/o port as valid */
+#define KDENABIO	0x4B36	/* enable i/o to video board */
+#define KDDISABIO	0x4B37	/* disable i/o to video board */
+
+#define KDSETMODE	0x4B3A	/* set text/graphics mode */
+#define KD_TEXT		0x00
+#define KD_GRAPHICS	0x01
+#define KD_TEXT0	0x02	/* obsolete */
+#define KD_TEXT1	0x03	/* obsolete */
+#define KDGETMODE	0x4B3B	/* get current mode */
+
+#define KDMAPDISP	0x4B3C	/* map display into address space */
+#define KDUNMAPDISP	0x4B3D	/* unmap display from address space */
+
+typedef char scrnmap_t;
+#define E_TABSZ		256
+#define GIO_SCRNMAP	0x4B40	/* get screen mapping from kernel */
+#define PIO_SCRNMAP	0x4B41	/* put screen mapping table in kernel */
+#define GIO_UNISCRNMAP  0x4B69	/* get full Unicode screen mapping */
+#define PIO_UNISCRNMAP  0x4B6A  /* set full Unicode screen mapping */
+
+#define GIO_UNIMAP	0x4B66	/* get unicode-to-font mapping from kernel */
+struct unipair {
+	unsigned short int unicode;
+	unsigned short int fontpos;
+};
+struct unimapdesc {
+	unsigned short int entry_ct;
+	struct unipair *entries;
+};
+#define PIO_UNIMAP	0x4B67	/* put unicode-to-font mapping in kernel */
+#define PIO_UNIMAPCLR	0x4B68	/* clear table, possibly advise hash algorithm */
+struct unimapinit {
+	unsigned short int advised_hashsize;  /* 0 if no opinion */
+	unsigned short int advised_hashstep;  /* 0 if no opinion */
+	unsigned short int advised_hashlevel; /* 0 if no opinion */
+};
+
+#define UNI_DIRECT_BASE 0xF000	/* start of Direct Font Region */
+#define UNI_DIRECT_MASK 0x01FF	/* Direct Font Region bitmask */
+
+#define K_RAW		0x00
+#define K_XLATE		0x01
+#define K_MEDIUMRAW	0x02
+#define K_UNICODE	0x03
+#define KDGKBMODE	0x4B44	/* gets current keyboard mode */
+#define KDSKBMODE	0x4B45	/* sets current keyboard mode */
+
+#define K_METABIT	0x03
+#define K_ESCPREFIX	0x04
+#define KDGKBMETA	0x4B62	/* gets meta key handling mode */
+#define KDSKBMETA	0x4B63	/* sets meta key handling mode */
+
+#define K_SCROLLLOCK	0x01
+#define K_NUMLOCK	0x02
+#define K_CAPSLOCK	0x04
+#define KDGKBLED	0x4B64	/* get led flags (not lights) */
+#define KDSKBLED	0x4B65	/* set led flags (not lights) */
+
+struct kbentry {
+	unsigned char kb_table;
+	unsigned char kb_index;
+	unsigned short int kb_value;
+};
+#define K_NORMTAB	0x00
+#define K_SHIFTTAB	0x01
+#define K_ALTTAB	0x02
+#define K_ALTSHIFTTAB	0x03
+
+#define KDGKBENT	0x4B46	/* gets one entry in translation table */
+#define KDSKBENT	0x4B47	/* sets one entry in translation table */
+
+struct kbsentry {
+	unsigned char kb_func;
+	unsigned char kb_string[512];
+};
+#define KDGKBSENT	0x4B48	/* gets one function key string entry */
+#define KDSKBSENT	0x4B49	/* sets one function key string entry */
+
+struct kbdiacr {
+        unsigned char diacr, base, result;
+};
+struct kbdiacrs {
+        unsigned int kb_cnt;    /* number of entries in following array */
+	struct kbdiacr kbdiacr[256];    /* MAX_DIACR from keyboard.h */
+};
+#define KDGKBDIACR      0x4B4A  /* read kernel accent table */
+#define KDSKBDIACR      0x4B4B  /* write kernel accent table */
+
+struct kbkeycode {
+	unsigned int scancode, keycode;
+};
+#define KDGETKEYCODE	0x4B4C	/* read kernel keycode table entry */
+#define KDSETKEYCODE	0x4B4D	/* write kernel keycode table entry */
+
+#define KDSIGACCEPT	0x4B4E	/* accept kbd generated signals */
+
+struct kbd_repeat {
+	int delay;	/* in msec; <= 0: don't change */
+	int rate;	/* in msec; <= 0: don't change */
+};
+
+#define KDKBDREP        0x4B52  /* set keyboard delay/repeat rate;
+				 * actually used values are returned */
+
+#define KDFONTOP	0x4B72	/* font operations */
+
+struct console_font_op {
+	unsigned int op;	/* operation code KD_FONT_OP_* */
+	unsigned int flags;	/* KD_FONT_FLAG_* */
+	unsigned int width, height;	/* font size */
+	unsigned int charcount;
+	unsigned char *data;	/* font data with height fixed to 32 */
+};
+
+#define KD_FONT_OP_SET		0	/* Set font */
+#define KD_FONT_OP_GET		1	/* Get font */
+#define KD_FONT_OP_SET_DEFAULT	2	/* Set font to default, data points to name / NULL */
+#define KD_FONT_OP_COPY		3	/* Copy from another console */
+
+#define KD_FONT_FLAG_DONT_RECALC 	1	/* Don't recalculate hw charcell size [compat] */
+#ifdef __KERNEL__
+#define KD_FONT_FLAG_OLD		0x80000000	/* Invoked via old interface [compat] */
+#endif
+
+/* note: 0x4B00-0x4B4E all have had a value at some time;
+   don't reuse for the time being */
+/* note: 0x4B60-0x4B6D, 0x4B70-0x4B72 used above */
+
+#endif /* _LINUX_KD_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/mman.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/mman.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/mman.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/mman.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,61 @@
+#ifndef MMAN_H
+#define MMAN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PROT_READ	0x1		/* page can be read */
+#define PROT_WRITE	0x2		/* page can be written */
+#define PROT_EXEC	0x4		/* page can be executed */
+#define PROT_NONE	0x0		/* page cannot be accessed */
+
+#define MAP_SHARED	0x01		/* share changes */
+#define MAP_PRIVATE	0x02		/* changes are private */
+#define MAP_TYPE	0x0f		/* mask for type of mapping */
+#define MAP_FIXED	0x10		/* interpret address exactly */
+#define MAP_ANONYMOUS	0x20		/* don't use the file descriptor */
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* -ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as a executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+
+#define ZERO_PAGE	0x80000000	/* this page must be zero-filled */
+
+#define MS_ASYNC	1		/* sync memory asynchronously */
+#define MS_INVALIDATE	2		/* invalidate the caches */
+#define MS_SYNC		4		/* synchronous memory sync */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+/* compatibility flags */
+#define MAP_ANON	MAP_ANONYMOUS
+#define MAP_FILE	0
+
+/* Return value of `mmap' in case of an error.  */
+#if !defined(MAP_FAILED)
+#define MAP_FAILED	((void *) -1)
+#endif
+
+struct mmap {
+	unsigned int start;
+	unsigned int length;
+	unsigned int prot;
+	unsigned int flags;
+	int fd;
+	unsigned int offset;
+};
+
+extern void *mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset);
+extern int munmap (void *__addr, size_t __len);
+extern int mprotect (void *__addr, size_t __len, int __prot);
+
+extern void *mmap2(void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MMAN_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/mount.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/mount.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/mount.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/mount.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,151 @@
+/* Header file for mounting/unmount Linux filesystems.
+   Copyright (C) 1996-2000, 2004, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This is taken from /usr/include/linux/fs.h.  */
+
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H	1
+
+#include <sys/ioctl.h>
+
+#define BLOCK_SIZE	1024
+#define BLOCK_SIZE_BITS	10
+
+
+/* These are the fs-independent mount-flags: up to 16 flags are
+   supported  */
+enum
+{
+  MS_RDONLY = 1,		/* Mount read-only.  */
+#define MS_RDONLY	MS_RDONLY
+  MS_NOSUID = 2,		/* Ignore suid and sgid bits.  */
+#define MS_NOSUID	MS_NOSUID
+  MS_NODEV = 4,			/* Disallow access to device special files.  */
+#define MS_NODEV	MS_NODEV
+  MS_NOEXEC = 8,		/* Disallow program execution.  */
+#define MS_NOEXEC	MS_NOEXEC
+  MS_SYNCHRONOUS = 16,		/* Writes are synced at once.  */
+#define MS_SYNCHRONOUS	MS_SYNCHRONOUS
+  MS_REMOUNT = 32,		/* Alter flags of a mounted FS.  */
+#define MS_REMOUNT	MS_REMOUNT
+  MS_MANDLOCK = 64,		/* Allow mandatory locks on an FS.  */
+#define MS_MANDLOCK	MS_MANDLOCK
+  MS_DIRSYNC = 128,		/* Directory modifications are synchronous.  */
+#define MS_DIRSYNC	MS_DIRSYNC
+  MS_NOATIME = 1024,		/* Do not update access times.  */
+#define MS_NOATIME	MS_NOATIME
+  MS_NODIRATIME = 2048,		/* Do not update directory access times.  */
+#define MS_NODIRATIME	MS_NODIRATIME
+  MS_BIND = 4096,		/* Bind directory at different place.  */
+#define MS_BIND		MS_BIND
+  MS_MOVE = 8192,
+#define MS_MOVE		MS_MOVE
+  MS_REC = 16384,
+#define MS_REC		MS_REC
+  MS_SILENT = 32768,
+#define MS_SILENT	MS_SILENT
+  MS_POSIXACL = 1 << 16,	/* VFS does not apply the umask.  */
+#define MS_POSIXACL	MS_POSIXACL
+  MS_UNBINDABLE = 1 << 17,	/* Change to unbindable.  */
+#define MS_UNBINDABLE	MS_UNBINDABLE
+  MS_PRIVATE = 1 << 18,		/* Change to private.  */
+#define MS_PRIVATE	MS_PRIVATE
+  MS_SLAVE = 1 << 19,		/* Change to slave.  */
+#define MS_SLAVE	MS_SLAVE
+  MS_SHARED = 1 << 20,		/* Change to shared.  */
+#define MS_SHARED	MS_SHARED
+  MS_RELATIME = 1 << 21,	/* Update atime relative to mtime/ctime.  */
+#define MS_RELATIME	MS_RELATIME
+  MS_KERNMOUNT = 1 << 22,	/* This is a kern_mount call.  */
+#define MS_KERNMOUNT	MS_KERNMOUNT
+  MS_I_VERSION =  1 << 23,	/* Update inode I_version field.  */
+#define MS_I_VERSION	MS_I_VERSION
+  MS_STRICTATIME = 1 << 24,	/* Always perform atime updates.  */
+#define MS_STRICTATIME	MS_STRICTATIME
+  MS_ACTIVE = 1 << 30,
+#define MS_ACTIVE	MS_ACTIVE
+  MS_NOUSER = 1 << 31
+#define MS_NOUSER	MS_NOUSER
+};
+
+/* Flags that can be altered by MS_REMOUNT  */
+#define MS_RMT_MASK (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)
+
+
+/* Magic mount flag number. Has to be or-ed to the flag values.  */
+
+#define MS_MGC_VAL 0xc0ed0000	/* Magic flag number to indicate "new" flags */
+#define MS_MGC_MSK 0xffff0000	/* Magic flag number mask */
+
+
+/* The read-only stuff doesn't really belong here, but any other place
+   is probably as bad and I don't want to create yet another include
+   file.  */
+
+#define BLKROSET   _IO(0x12, 93) /* Set device read-only (0 = read-write).  */
+#define BLKROGET   _IO(0x12, 94) /* Get read-only status (0 = read_write).  */
+#define BLKRRPART  _IO(0x12, 95) /* Re-read partition table.  */
+#define BLKGETSIZE _IO(0x12, 96) /* Return device size.  */
+#define BLKFLSBUF  _IO(0x12, 97) /* Flush buffer cache.  */
+#define BLKRASET   _IO(0x12, 98) /* Set read ahead for block device.  */
+#define BLKRAGET   _IO(0x12, 99) /* Get current read ahead setting.  */
+#define BLKFRASET  _IO(0x12,100) /* Set filesystem read-ahead.  */
+#define BLKFRAGET  _IO(0x12,101) /* Get filesystem read-ahead.  */
+#define BLKSECTSET _IO(0x12,102) /* Set max sectors per request.  */
+#define BLKSECTGET _IO(0x12,103) /* Get max sectors per request.  */
+#define BLKSSZGET  _IO(0x12,104) /* Get block device sector size.  */
+#define BLKBSZGET  _IOR(0x12,112,size_t)
+#define BLKBSZSET  _IOW(0x12,113,size_t)
+#define BLKGETSIZE64 _IOR(0x12,114,size_t) /* return device size.  */
+
+
+/* Possible value for FLAGS parameter of `umount2'.  */
+enum
+{
+  MNT_FORCE = 1,		/* Force unmounting.  */
+#define MNT_FORCE MNT_FORCE
+  MNT_DETACH = 2,		/* Just detach from the tree.  */
+#define MNT_DETACH MNT_DETACH
+  MNT_EXPIRE = 4,		/* Mark for expiry.  */
+#define MNT_EXPIRE MNT_EXPIRE
+  UMOUNT_NOFOLLOW = 8		/* Don't follow symlink on umount.  */
+#define UMOUNT_NOFOLLOW UMOUNT_NOFOLLOW
+};
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Mount a filesystem.  */
+extern int mount (__const char *__special_file, __const char *__dir,
+		  __const char *__fstype, unsigned int __rwflag,
+		  __const void *__data);
+
+/* Unmount a filesystem.  */
+extern int umount (__const char *__special_file);
+
+/* Unmount a filesystem.  Force unmounting if FLAGS is set to MNT_FORCE.  */
+extern int umount2 (__const char *__special_file, int __flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_MOUNT_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/msg.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/msg.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/msg.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/msg.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,52 @@
+#ifndef _SYS_MSG_H
+#define _SYS_MSG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/ipc.h>
+
+#define MSG_NOERROR	010000		/* no error if message is too big */
+
+#define MSG_STAT	11
+#define MSG_INFO	12
+
+struct msqid_ds {
+	struct ipc_perm msg_perm;	/* access permissions */
+	struct msg *msg_first;		/* ptr to the first message in queue */
+	struct msg *msg_last;		/* ptr to the last message in queue */
+	__time_t msg_stime;		/* time of the last msgsnd() */
+	__time_t msg_rtime;		/* time of the last msgrcv() */
+	__time_t msg_ctime;		/* time of the last change time */
+	unsigned int unused1;
+	unsigned int unused2;
+	unsigned short int msg_cbytes;	/* number of bytes in queue */
+	unsigned short int msg_qnum;	/* number of messages in queue */
+	unsigned short int msg_qbytes;	/* max. number of bytes in queue */
+	unsigned short int msg_lspid;	/* PID of last msgsnd() */
+	unsigned short int msg_lrpid;	/* PID of last msgrcv() */
+};
+
+/* buffer for msgctl() with IPC_INFO and MSG_INFO commands */
+struct msginfo {
+	int msgpool;
+	int msgmap;
+	int msgmax;			/* MSGMAX */
+	int msgmnb;			/* MSGMNB */
+	int msgmni;			/* MSGMNI */
+	int msgssz;
+	int msgtql;			/* MSGTQL */
+	unsigned short int msgseg;
+};
+
+extern int msgsnd(int, const void *, size_t, int);
+extern ssize_t msgrcv(int, void *, size_t, int, int);
+extern int msgget(key_t, int);
+extern int msgctl(int, int, struct msqid_ds *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_MSG_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/param.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/param.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/param.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/param.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,37 @@
+/* This is a dummy <sys/param.h> file, not customized for any
+   particular system.  If there is a param.h in libc/sys/SYSDIR/sys,
+   it will override this one.  */
+
+#ifndef _SYS_PARAM_H
+# define _SYS_PARAM_H
+
+#include <sys/config.h>
+#include <sys/syslimits.h>
+#include <machine/endian.h>
+#include <machine/param.h>
+
+#ifndef NBBY
+# define NBBY 8		/* number of bits in a byte */
+#endif
+#ifndef HZ
+# define HZ (60)
+#endif
+#ifndef NOFILE
+# define NOFILE	(60)
+#endif
+#ifndef PATHSIZE
+# define PATHSIZE (1024)
+#endif
+
+#define MAXPATHLEN PATH_MAX
+#define MAXSYMLINKS 20
+#define MAXHOSTNAMELEN 64
+
+#define MAX(a,b) ((a) > (b) ? (a) : (b))
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+
+#ifndef howmany
+#define    howmany(x, y)   (((x)+((y)-1))/(y))
+#endif
+
+#endif
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/reboot.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/reboot.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/reboot.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/reboot.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,19 @@
+#ifndef _SYS_REBOOT_H
+#define _SYS_REBOOT_H
+
+/* perform a hard reset immediately */
+#define RB_AUTOBOOT	0x01234567
+
+/* halt the system */
+#define RB_HALT_SYSTEM	0xcdef0123
+
+/* enable reboot using CTRL+ALT+DEL keystroke */
+#define RB_ENABLE_CAD	0x89abcdef
+
+/* disable reboot using CTRL+ALT+DEL keystroke */
+#define RB_DISABLE_CAD	0
+
+/* reboot or halt de system */
+extern int reboot (int, int, int);
+
+#endif /* _SYS_REBOOT_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/resource.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/resource.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/resource.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/resource.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,87 @@
+#ifndef _SYS_RESOURCE_H
+#define _SYS_RESOURCE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/time.h>
+
+#define RLIMIT_INFINITY	0x7FFFFFFF	/* value to indicate "no limit" */
+#define RLIM_INFINITY	RLIMIT_INFINITY	/* traditional name */
+
+#define RUSAGE_SELF	0		/* the calling process */
+#define RUSAGE_CHILDREN	(-1)		/* all of its termin. child processes */
+
+#define RLIMIT_CPU	0		/* per-process CPU limit (secs) */
+#define RLIMIT_FSIZE	1		/* largest file that can be created
+					   (bytes */
+#define RLIMIT_DATA	2		/* maximum size of data segment
+					   (bytes) */
+#define RLIMIT_STACK	3		/* maximum size of stack segment
+					   (bytes) */
+#define RLIMIT_CORE	4		/* largest core file that can be created
+					   (bytes) */
+#define RLIMIT_RSS	5		/* largest resident set size (bytes) */
+#define RLIMIT_NPROC	6		/* number of processes */
+#define RLIMIT_NOFILE	7		/* number of open files */
+#define RLIMIT_MEMLOCK	8		/* locked-in-memory address space */
+#define RLIMIT_AS	9		/* address space limit */
+
+#define RLIM_NLIMITS	10
+
+typedef unsigned long 	rlim_t;
+
+struct rusage {
+	struct timeval ru_utime;	/* total amount of user time used */
+	struct timeval ru_stime;	/* total amount of system time used */
+	long ru_maxrss;			/* maximum resident set size (KB) */
+	long ru_ixrss;			/* amount of sharing of text segment
+					   memory with other processes
+					   (KB-secs) */
+	long ru_idrss;			/* amount of data segment memory used
+					   (KB-secs) */
+	long ru_isrss;			/* amount of stack memory used
+					   (KB-secs) */
+	long ru_minflt;			/* number of soft page faults (i.e.
+					   those serviced by reclaiming a page
+					   from the list of pages awaiting
+					   rellocation) */
+	long ru_majflt;			/* number of hard page faults (i.e.
+					   those that required I/O) */
+	long ru_nswap;			/* number of times a process was swapped
+					   out of physical memory */
+	long ru_inblock;		/* number of input operations via the
+					   file system. Note this and
+					   'ru_outblock' do not include
+					   operations with the cache */
+	long ru_oublock;		/* number of output operations via the
+					   file system */
+	long ru_msgsnd;			/* number of IPC messages sent */
+	long ru_msgrcv;			/* number of IPC messages received */
+	long ru_nsignals;		/* number of signals delivered */
+	long ru_nvcsw;			/* number of voluntary context switches,
+					   i.e. because the process gave up the
+					   process before it had to (usually to
+					   wait for some resouce to be
+					   availabe */
+	long ru_nivcsw;			/* number of involuntary context
+					   switches. i.e. a higher priority
+					   process became runnable or the
+					   current process used up its time
+					   slice */
+};
+
+struct rlimit {
+	int rlim_cur;			/* the current (soft) limit */
+	int rlim_max;			/* the maximum (hard) limit */
+};
+
+int	getrusage(int, struct rusage*);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SYS_RESOURCE_H */
+
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/sem.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/sem.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/sem.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/sem.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,89 @@
+#ifndef _FIWIX_SEM_H
+#define _FIWIX_SEM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/ipc.h>
+
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* semctl() command definitions */
+#define GETPID		11		/* get sempid */
+#define GETVAL		12		/* get semval */
+#define GETALL		13		/* get all semval's */
+#define GETNCNT		14		/* get semncnt */
+#define GETZCNT		15		/* get semzcnt */
+#define SETVAL		16		/* set semval */
+#define SETALL		17		/* set all semval's */
+
+#define SEM_STAT	18
+#define SEM_INFO	19
+
+struct semid_ds {
+	struct ipc_perm sem_perm;	/* access permissions */
+	__time_t sem_otime;		/* time of the last semop() */
+	__time_t sem_ctime;		/* time of the last change time */
+	struct sem *sem_base;		/* ptr to the first semaphore in set */
+	unsigned int unused1;
+	unsigned int unused2;
+	struct sem_undo *undo;		/* list of undo requests */
+	unsigned short int sem_nsems;	/* number of semaphores in set */
+};
+
+/* semaphore buffer for semop() */
+struct sembuf {
+	unsigned short int sem_num;	/* semaphore number */
+	short int sem_op;		/* semaphore operation */
+	short int sem_flg;		/* operation flags */
+};
+
+/* arg for semctl() */
+union semun {
+	int val;			/* value for SETVAL */
+	struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
+	unsigned short int *array;	/* array for GETALL & SETALL */
+	struct seminfo *__buf;		/* buffer for IPC_INFO */
+};
+
+/* semaphore information structure */
+struct seminfo {
+	int semmap;
+	int semmni;
+	int semmns;
+	int semmnu;
+	int semmsl;
+	int semopm;
+	int semume;
+	int semusz;
+	int semvmx;
+	int semaem;
+};
+
+/* one semaphore structure for each semaphore in the system */
+struct sem {
+	short int semval;		/* current value */
+	short int sempid;		/* pid of last operation */
+	short int semncnt;		/* nprocs awaiting increase in semval */
+	short int semzcnt;		/* nprocs awaiting semval = 0 */
+};
+
+/* list of undo requests executed automatically when the process exits */
+struct sem_undo {
+	struct sem_undo *proc_next;	/* next entry on this process */
+	struct sem_undo *id_next;	/* next entry on this semaphore set */
+	int semid;			/* semaphore set identifier */
+	short int semadj;		/* adjustment during exit() */
+	unsigned short int sem_num;	/* semaphore number */
+};
+
+extern int sys_semop(int, struct sembuf *, int);
+extern int sys_semget(key_t, int, int);
+extern int sys_semctl(int, int, int, void *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FIWIX_SEM_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/shm.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/shm.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/shm.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/shm.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,61 @@
+#ifndef _FIWIX_SHM_H
+#define _FIWIX_SHM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/ipc.h>
+
+#define	SHM_RDONLY	010000		/* attach a read-only segment */
+#define	SHM_RND		020000		/* round attach address to SHMLBA */
+#define	SHM_REMAP	040000		/* take-over region on attach */
+
+/* super user shmctl commands */
+#define SHM_LOCK 	11
+#define SHM_UNLOCK 	12
+
+#define SHM_STAT 	13
+#define SHM_INFO 	14
+
+struct shmid_ds {
+	struct ipc_perm shm_perm;	/* access permissions */
+	__size_t shm_segsz;		/* size of segment (in bytes) */
+	__time_t shm_atime;		/* time of the last shmat() */
+	__time_t shm_dtime;		/* time of the last shmdt() */
+	__time_t shm_ctime;		/* time of the last change time */
+	unsigned short shm_cpid;	/* pid of creator */
+	unsigned short shm_lpid;	/* pid of last shmop */
+	unsigned short shm_nattch;	/* num. of current attaches */
+	unsigned short shm_unused1;
+	void *shm_unused2;
+	void *shm_unused3;
+};
+
+struct shminfo {
+	int shmmax;
+	int shmmin;
+	int shmmni;
+	int shmseg;
+	int shmall;
+};
+
+struct shm_info {
+	int used_ids;
+	unsigned int shm_tot;	/* total allocated shm */
+	unsigned int shm_rss;	/* total resident shm */
+	unsigned int shm_swp;	/* total swapped shm */
+	unsigned int swap_attempts;
+	unsigned int swap_successes;
+};
+
+extern void *shmat(int, const void *, int);
+extern int shmdt(const void *);
+extern int shmget(key_t, __size_t, int);
+extern int shmctl(int, int, struct shmid_ds *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FIWIX_SHM_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/signal.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/signal.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/signal.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/signal.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,58 @@
+/* libc/sys/linux/sys/signal.h - Signal handling */
+
+/* Written 2000 by Werner Almesberger */
+
+
+#ifndef _SYS_SIGNAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define _SYS_SIGNAL_H
+#define _SIGNAL_H
+
+#include <sys/types.h>
+//#include <bits/sigset.h>
+#include <bits/signum.h>
+
+/* we want RT signals so we must override the definition of sigset_t
+   and NSIG
+
+#undef NSIG
+#define NSIG _NSIG
+#undef sigset_t
+*/
+
+typedef unsigned long __sigset_t;
+#define sigset_t __sigset_t
+
+typedef void (*_sig_func_ptr) (int);
+typedef _sig_func_ptr __sighandler_t;
+
+#include <bits/siginfo.h>
+#include <bits/sigaction.h>
+
+/* --- redundant stuff below --- */
+
+#include <_ansi.h>
+
+int 	kill(int, int);
+int 	sigaction(int, const struct sigaction *, struct sigaction *);
+int 	sigaddset(sigset_t *, const int);
+int 	sigdelset(sigset_t *, const int);
+int 	sigismember(const sigset_t *, int);
+int 	sigfillset(sigset_t *);
+int 	sigemptyset(sigset_t *);
+int 	sigpending(sigset_t *);
+int 	sigsuspend(const sigset_t *);
+int 	sigpause(int);
+int	sigprocmask(int how, const sigset_t *set, sigset_t *oset);
+
+
+#ifndef _POSIX_SOURCE
+extern const char *const sys_siglist[];
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif	/* _SYS_SIGNAL_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/socket.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/socket.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/socket.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/socket.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,86 @@
+#ifndef _SYS_SOCKET_H
+#define	_SYS_SOCKET_H
+
+#include <sys/types.h>
+#include <netdb.h>
+
+typedef unsigned int socklen_t;
+typedef unsigned short int sa_family_t;
+
+/* address families */
+#define	AF_UNSPEC	0		/* unspecified */
+#define	AF_UNIX		1		/* UNIX domain socket */
+#define	AF_LOCAL	AF_UNIX
+#define	AF_FILE		AF_UNIX
+#define	AF_INET		2		/* Internet: UDP, TCP, ... */
+
+/* protocol families */
+#define	PF_UNSPEC	AF_UNSPEC
+#define	PF_UNIX		AF_UNIX
+#define	PF_LOCAL	AF_UNIX
+#define	PF_FILE		AF_UNIX
+#define	PF_INET		AF_INET
+
+/* types */
+#define	SOCK_STREAM	1		/* stream socket */
+#define	SOCK_DGRAM	2		/* datagram socket */
+
+/* flags */
+#define	SO_ACCEPTCONN	0x0002		/* socket has had listen() */
+#define	SO_REUSEADDR	0x0004		/* allow local address reuse */
+
+
+/* generic socket address structure */
+struct sockaddr {
+	sa_family_t sa_family;		/* address family: AF_xxx */
+	char sa_data[14];		/* protocol specific address */
+};
+
+#define	SOCK_MAXADDRLEN	255		/* longest possible addresses */
+
+/* maximum queue length specifiable by listen() */
+#ifndef	SOMAXCONN
+#define	SOMAXCONN	128
+#endif
+
+/*
+ * Message header for recvmsg and sendmsg calls.
+ * Used value-result for recvmsg, value only for sendmsg.
+ */
+struct msghdr {
+	void		*msg_name;		/* optional address */
+	socklen_t	 msg_namelen;		/* size of address */
+	struct iovec	*msg_iov;		/* scatter/gather array */
+	int		 msg_iovlen;		/* # elements in msg_iov */
+	void		*msg_control;		/* ancillary data, see below */
+	socklen_t	 msg_controllen;	/* ancillary data buffer len */
+	int		 msg_flags;		/* flags on received message */
+};
+
+#define	MSG_PEEK	0x2		/* peek at incoming message */
+#define	MSG_DONTWAIT	0x80		/* this message should be nonblocking */
+
+/* arguments for shutdown(2) */
+#define	SHUT_RD		0		/* shut down the reading side */
+#define	SHUT_WR		1		/* shut down the writing side */
+#define	SHUT_RDWR	2		/* shut down both sides */
+
+__BEGIN_DECLS
+int	socket(int, int, int);
+int	bind(int, const struct sockaddr *, socklen_t);
+int	connect(int, const struct sockaddr *, socklen_t);
+int	listen(int, int);
+int	accept(int, struct sockaddr *, socklen_t *);
+int	getsockname(int, struct sockaddr *, socklen_t *);
+int	getpeername(int, struct sockaddr *, socklen_t *);
+int	socketpair(int, int, int, int *);
+ssize_t	send(int, const void *, size_t, int);
+ssize_t	recv(int, void *, size_t, int);
+ssize_t	sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t);
+ssize_t	recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
+int	shutdown(int, int);
+int	setsockopt(int, int, int, const void *, socklen_t);
+int	getsockopt(int, int, int, void *, socklen_t *);
+__END_DECLS
+
+#endif /* _SYS_SOCKET_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/stat.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/stat.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/stat.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/stat.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,134 @@
+#ifndef _SYS_STAT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define _SYS_STAT_H
+
+#include <sys/types.h>
+
+struct old_stat {
+	unsigned short int st_dev;
+	unsigned short int st_ino;
+	unsigned short int st_mode;
+	unsigned short int st_nlink;
+	uid_t st_uid;
+	gid_t st_gid;
+	unsigned short int st_rdev;
+	unsigned int st_size;
+	time_t st_atime;
+	time_t st_mtime;
+	time_t st_ctime;
+};
+
+struct stat {
+	unsigned short int st_dev;
+	unsigned short int __pad1;
+	unsigned int st_ino;
+	unsigned short int st_mode;
+	unsigned short int st_nlink;
+	uid_t st_uid;
+	gid_t st_gid;
+	unsigned short int st_rdev;
+	unsigned short int __pad2;
+	unsigned int st_size;
+	unsigned int st_blksize;
+	unsigned int st_blocks;
+	time_t st_atime;
+	unsigned int __unused1;
+	time_t st_mtime;
+	unsigned int __unused2;
+	time_t st_ctime;
+	unsigned int __unused3;
+	unsigned int __unused4;
+	unsigned int __unused5;
+};
+
+/* 64bit structure for i386 */
+struct stat64 {
+	unsigned long long int st_dev;
+	int __st_dev_padding;
+	int __st_ino_truncated;
+	unsigned int st_mode;
+	unsigned int st_nlink;
+	unsigned int st_uid;
+	unsigned int st_gid;
+	unsigned long long int st_rdev;
+	int __st_rdev_padding;
+	long long int st_size;
+	int st_blksize;
+	long long int st_blocks;
+	int st_atime;
+	int st_atime_nsec;
+	int st_mtime;
+	int st_mtime_nsec;
+	int st_ctime;
+	int st_ctime_nsec;
+	unsigned long long int st_ino;
+};
+
+/* Encoding of the file mode.  These are the standard Unix values,
+   but POSIX.1 does not specify what values should be used.  */
+
+#define S_IFMT		0170000		/* Type of file mask */
+
+/* File types.  */
+#define S_IFIFO		0010000		/* Named pipe (fifo) */
+#define S_IFCHR		0020000		/* Character special */
+#define S_IFDIR		0040000		/* Directory */
+#define S_IFBLK		0060000		/* Block special */
+#define S_IFREG		0100000		/* Regular */
+#define S_IFLNK		0120000		/* Symbolic link */
+#define S_IFSOCK 	0140000		/* Socket */
+
+/* Protection bits.  */
+#define S_IXUSR		00100		/* USER   --x------ */
+#define S_IWUSR		00200		/* USER   -w------- */
+#define S_IRUSR		00400		/* USER   r-------- */
+#define S_IRWXU		00700		/* USER   rwx------ */
+
+#define S_IXGRP		00010		/* GROUP  -----x--- */
+#define S_IWGRP		00020		/* GROUP  ----w---- */
+#define S_IRGRP		00040		/* GROUP  ---r----- */
+#define S_IRWXG		00070		/* GROUP  ---rwx--- */
+
+#define S_IXOTH		00001		/* OTHERS --------x */
+#define S_IWOTH		00002		/* OTHERS -------w- */
+#define S_IROTH		00004		/* OTHERS ------r-- */
+#define S_IRWXO		00007		/* OTHERS ------rwx */
+
+#define S_ISUID		0004000		/* set user id on execution */
+#define S_ISGID		0002000		/* set group id on execution */
+#define S_ISVTX		0001000		/* sticky bit */
+
+#define S_IREAD		S_IRUSR		/* Read by owner.  */
+#define S_IWRITE	S_IWUSR		/* Write by owner.  */
+#define S_IEXEC		S_IXUSR		/* Execute by owner.  */
+
+#define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
+#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
+#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
+#define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
+#define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
+#define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
+#define S_ISSOCK(m) 	(((m) & S_IFMT) == S_IFSOCK)
+
+#define R_OK		4		/* test for read permission */
+#define W_OK		2		/* test for write permission */
+#define X_OK		1		/* test for execute permission */
+
+int	fstat( int __fd, struct stat *__sbuf );
+int	mkdir( const char *_path, mode_t __mode );
+int	mkfifo( const char *__path, mode_t __mode );
+int	stat( const char * __path, struct stat * __sbuf );
+mode_t	umask( mode_t __mask );
+int	lstat(const char * __path, struct stat * __buf);
+
+/* 64bit functions for i386 */
+int	stat64(const char *, struct stat64 *);
+int	lstat64(const char *, struct stat64 *);
+int	fstat64(unsigned int, struct stat64 *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_STAT_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/statfs.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/statfs.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/statfs.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/statfs.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,21 @@
+#ifndef _SYS_STATFS_H
+#define _SYS_STATFS_H
+
+typedef struct {
+	long    val[2];
+} fsid_t;
+
+struct statfs {
+	long f_type;
+	long f_bsize;
+	long f_blocks;
+	long f_bfree;
+	long f_bavail;
+	long f_files;
+	long f_ffree;
+	fsid_t f_fsid;
+	long f_namelen;
+	long f_spare[6];
+};
+
+#endif /* _SYS_STATFS_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/sysinfo.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/sysinfo.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/sysinfo.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/sysinfo.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,19 @@
+#ifndef _SYS_SYSINFO_H
+#define _SYS_SYSINFO_H
+
+struct sysinfo {
+	int uptime;			/* seconds since boot */
+	unsigned int loads[3];		/* load average (1, 5 and 15 minutes) */
+	unsigned int totalram;		/* total usable main memory size */
+	unsigned int freeram;		/* available memory size */
+	unsigned int sharedram;		/* amount of shared memory */
+	unsigned int bufferram;		/* amount of memory used by buffers */
+	unsigned int totalswap;		/* total swap space size */
+	unsigned int freeswap;		/* available swap space */
+	unsigned short int procs;	/* number of current processes */
+	char _f[22];			/* pads structure to 64 bytes */
+};
+
+int	sysinfo(struct sysinfo *info);
+
+#endif /* _SYS_SYSINFO_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/syslimits.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/syslimits.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/syslimits.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/syslimits.h	2025-04-19 07:17:37 +0000
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)syslimits.h	8.1 (Berkeley) 6/2/93
+ * $FreeBSD: src/sys/sys/syslimits.h,v 1.10 2001/06/18 20:24:54 wollman Exp $
+ */
+
+#ifndef _SYS_SYSLIMITS_H_
+#define _SYS_SYSLIMITS_H_
+
+#define	ARG_MAX			65536	/* max bytes for an exec function */
+#ifndef CHILD_MAX
+#define	CHILD_MAX		   40	/* max simultaneous processes */
+#endif
+#define	LINK_MAX		32767	/* max file link count */
+#define	MAX_CANON		  255	/* max bytes in term canon input line */
+#define	MAX_INPUT		  255	/* max bytes in terminal input */
+#define	NAME_MAX		  255	/* max bytes in a file name */
+#define	NGROUPS_MAX		   16	/* max supplemental group id's */
+#ifndef OPEN_MAX
+#define	OPEN_MAX		  256	/* max open files per process */
+#endif
+#define	PATH_MAX		 1024	/* max bytes in pathname */
+#define	PIPE_BUF		 4096	/* max bytes for atomic pipe writes */
+#define	IOV_MAX			 1024	/* max elements in i/o vector */
+
+#define	BC_BASE_MAX		   99	/* max ibase/obase values in bc(1) */
+#define	BC_DIM_MAX		 2048	/* max array elements in bc(1) */
+#define	BC_SCALE_MAX		   99	/* max scale value in bc(1) */
+#define	BC_STRING_MAX		 1000	/* max const string length in bc(1) */
+#define	COLL_WEIGHTS_MAX	    0	/* max weights for order keyword */
+#define	EXPR_NEST_MAX		   32	/* max expressions nested in expr(1) */
+#define	LINE_MAX		 2048	/* max bytes in an input line */
+#define	RE_DUP_MAX		  255	/* max RE's in interval notation */
+
+#endif
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/sysmacros.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/sysmacros.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/sysmacros.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/sysmacros.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,11 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#include <sys/types.h>
+
+#define major(__dev)	(((dev_t) (__dev)) >> 8)
+#define minor(__dev)	(((dev_t) (__dev)) & 0xFF)
+
+dev_t makedev(unsigned int, unsigned int);
+
+#endif /* _SYS_SYSMACROS_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/termio.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/termio.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/termio.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/termio.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,18 @@
+#ifndef _SYS_TERMIO_H
+#define _SYS_TERMIO_H
+
+#include <machine/termbits.h>
+#include <machine/termios.h>
+
+#define NCC	8
+
+struct termio {
+	unsigned short int c_iflag;	/* input mode flags */
+	unsigned short int c_oflag;	/* output mode flags */
+	unsigned short int c_cflag;	/* control mode flags */
+	unsigned short int c_lflag;	/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+#endif /* _SYS_TERMIO_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/termios.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/termios.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/termios.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/termios.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,31 @@
+#ifndef _SYS_TERMIOS_H
+#define _SYS_TERMIOS_H
+
+#include <sys/types.h>
+#include <machine/termbits.h>
+#include <machine/termios.h>
+
+#define NCCS 19
+
+/* Terminal control structure.  */
+struct termios {
+	tcflag_t c_iflag;	/* Input mode flags */
+	tcflag_t c_oflag;	/* Output mode flags */
+	tcflag_t c_cflag;	/* Control mode flags */
+	tcflag_t c_lflag;	/* Local mode flags */
+	cc_t c_line;		/* Line discipline */
+	cc_t c_cc[NCCS];	/* Control characters */
+};
+
+int tcgetattr(int, struct termios *);
+int tcsetattr(int, int, const struct termios *);
+pid_t tcgetpgrp(int);
+int tcsetpgrp(int, pid_t);
+int tcflow(int, int);
+int tcflush(int, int);
+void cfmakeraw(struct termios *);
+int tcdrain(int);
+char *ctermid(char *);
+int tcsendbreak(int, int);
+
+#endif /* _SYS_TERMIOS_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/uio.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/uio.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/uio.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/uio.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,14 @@
+#ifndef _SYS_UIO_H
+#define _SYS_UIO_H
+
+#include <sys/types.h>
+
+struct iovec {
+	void *iov_base;
+	size_t iov_len;
+};
+
+ssize_t readv(int, const struct iovec *, int);
+ssize_t writev(int, const struct iovec *, int);
+
+#endif	/* _SYS_UIO_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/un.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/un.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/un.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/un.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,15 @@
+#ifndef _SYS_UN_H
+#define _SYS_UN_H
+
+#include <sys/socket.h>
+
+/* structure describing the address of an AF_UNIX socket */
+struct sockaddr_un {
+	sa_family_t sun_family;
+	char sun_path[108];
+};
+
+/* evaluate to actual length of the 'sockaddr_un' structure */
+#define SUN_LEN(ptr)	((size_t) (((struct sockaddr_un *) 0)->sun_path) + strlen ((ptr)->sun_path))
+
+#endif /* _SYS_UN_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/unistd.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/unistd.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/unistd.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/unistd.h	2025-04-05 18:28:18 +0000
@@ -0,0 +1,619 @@
+#ifndef _SYS_UNISTD_H
+#define _SYS_UNISTD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#define __need_size_t
+#define __need_ptrdiff_t
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/_types.h>
+#include <stddef.h>
+
+/* 
+ * This file is from Newlib 4.4.0.
+ *
+ * Changes specific for Fiwix:
+ *    - included the two variables '__argv' and '__progname'.
+ *    - added the following prototypes:
+ *      - llseek.
+ *      - truncate64.
+ *      - ftruncate64.
+ *      - chown32.
+ *      - posix_openpt.
+ *      - grantpt.
+ *      - unlockpt.
+ *      - ptsname.
+ */
+extern char **__argv;
+extern char *__progname;
+
+extern char **environ;
+
+void	_exit (int __status) _ATTRIBUTE ((__noreturn__));
+
+int	access (const char *__path, int __amode);
+unsigned  alarm (unsigned __secs);
+int     chdir (const char *__path);
+int     chmod (const char *__path, mode_t __mode);
+int     chown (const char *__path, uid_t __owner, gid_t __group);
+int     chown32(const char *, unsigned int, unsigned int);
+
+int posix_openpt (int __oflag);
+int grantpt (int __fd);
+int unlockpt (int __fd);
+char *ptsname (int __fd);
+
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200112)
+int     chroot (const char *__path);
+#endif
+int     close (int __fildes);
+#if __POSIX_VISIBLE >= 199209
+size_t	confstr (int __name, char *__buf, size_t __len);
+#endif
+#if __XSI_VISIBLE
+char *  crypt (const char *__key, const char *__salt);
+#endif
+#if __XSI_VISIBLE && __XSI_VISIBLE < 700
+char *  ctermid (char *__s);
+#endif
+#if __XSI_VISIBLE && __XSI_VISIBLE < 600
+char *  cuserid (char *__s);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+int	daemon (int nochdir, int noclose);
+#endif
+int     dup (int __fildes);
+int     dup2 (int __fildes, int __fildes2);
+#if __GNU_VISIBLE
+int     dup3 (int __fildes, int __fildes2, int flags);
+int	eaccess (const char *__path, int __mode);
+#endif
+#if __XSI_VISIBLE
+void	encrypt (char *__block, int __edflag);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+void	endusershell (void);
+#endif
+#if __GNU_VISIBLE
+int	euidaccess (const char *__path, int __mode);
+#endif
+int     execl (const char *__path, const char *, ...);
+int     execle (const char *__path, const char *, ...);
+int     execlp (const char *__file, const char *, ...);
+#if __MISC_VISIBLE
+int     execlpe (const char *__file, const char *, ...);
+#endif
+int     execv (const char *__path, char * const __argv[]);
+int     execve (const char *__path, char * const __argv[], char * const __envp[]);
+int     execvp (const char *__file, char * const __argv[]);
+#if __GNU_VISIBLE
+int     execvpe (const char *__file, char * const __argv[], char * const __envp[]);
+#endif
+#if __ATFILE_VISIBLE
+int	faccessat (int __dirfd, const char *__path, int __mode, int __flags);
+#endif
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int     fchdir (int __fildes);
+#endif
+#if __POSIX_VISIBLE >= 199309
+int     fchmod (int __fildes, mode_t __mode);
+#endif
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int     fchown (int __fildes, uid_t __owner, gid_t __group);
+#endif
+#if __ATFILE_VISIBLE
+int	fchownat (int __dirfd, const char *__path, uid_t __owner, gid_t __group, int __flags);
+#endif
+#if __POSIX_VISIBLE >= 200809
+int	fexecve (int __fd, char * const __argv[], char * const __envp[]);
+#endif
+pid_t   fork (void);
+long    fpathconf (int __fd, int __name);
+int     fsync (int __fd);
+#if __POSIX_VISIBLE >= 199309
+int     fdatasync (int __fd);
+#endif
+#if __GNU_VISIBLE
+char *  get_current_dir_name (void);
+#endif
+char *  getcwd (char *__buf, size_t __size);
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+int	getdomainname  (char *__name, size_t __len);
+#endif
+#if __BSD_VISIBLE
+int     getentropy (void *, size_t);
+#endif
+gid_t   getegid (void);
+uid_t   geteuid (void);
+gid_t   getgid (void);
+int     getgroups (int __gidsetsize, gid_t __grouplist[]);
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4
+long    gethostid (void);
+#endif
+char *  getlogin (void);
+#if defined(_POSIX_THREAD_SAFE_FUNCTIONS)
+int getlogin_r (char *name, size_t namesize) ;
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __POSIX_VISIBLE < 200112)
+char *  getpass (const char *__prompt);
+int	getpagesize (void);
+#endif
+#if __BSD_VISIBLE
+int    getpeereid (int, uid_t *, gid_t *);
+#endif
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 4
+pid_t   getpgid (pid_t);
+#endif
+pid_t   getpgrp (void);
+pid_t   getpid (void);
+pid_t   getppid (void);
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 4
+pid_t   getsid (pid_t);
+#endif
+uid_t   getuid (void);
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+char *	getusershell (void);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200809)
+char *  getwd (char *__buf);
+#endif
+#if __BSD_VISIBLE
+int	iruserok (unsigned long raddr, int superuser, const char *ruser, const char *luser);
+#endif
+int     isatty (int __fildes);
+#if __BSD_VISIBLE
+int        issetugid (void);
+#endif
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int     lchown (const char *__path, uid_t __owner, gid_t __group);
+#endif
+int     link (const char *__path1, const char *__path2);
+#if __ATFILE_VISIBLE
+int     linkat (int __dirfd1, const char *__path1, int __dirfd2, const char *__path2, int __flags);
+#endif
+#if __MISC_VISIBLE || __XSI_VISIBLE
+int	nice (int __nice_value);
+#endif
+#if !defined(__INSIDE_CYGWIN__)
+off_t   lseek (int __fildes, off_t __offset, int __whence);
+off_t   llseek (unsigned int, unsigned int, unsigned int, _off64_t *, unsigned int);
+#endif
+#if __MISC_VISIBLE || __XSI_VISIBLE >= 4
+#define F_ULOCK	0
+#define F_LOCK	1
+#define F_TLOCK	2
+#define F_TEST	3
+int     lockf (int __fd, int __cmd, off_t __len);
+#endif
+long    pathconf (const char *__path, int __name);
+int     pause (void);
+#if __POSIX_VISIBLE >= 199506
+int	pthread_atfork (void (*)(void), void (*)(void), void (*)(void));
+#endif
+int     pipe (int __fildes[2]);
+#if __GNU_VISIBLE
+int     pipe2 (int __fildes[2], int flags);
+#endif
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 500
+ssize_t pread (int __fd, void *__buf, size_t __nbytes, off_t __offset);
+ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, off_t __offset);
+#endif
+_READ_WRITE_RETURN_TYPE read (int __fd, void *__buf, size_t __nbyte);
+#if __BSD_VISIBLE
+int	rresvport (int *__alport);
+int	revoke (char *__path);
+#endif
+int     rmdir (const char *__path);
+#if __BSD_VISIBLE
+int	ruserok (const char *rhost, int superuser, const char *ruser, const char *luser);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200112)
+void *  sbrk (ptrdiff_t __incr);
+#endif
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200112
+int     setegid (gid_t __gid);
+int     seteuid (uid_t __uid);
+#endif
+int     setgid (gid_t __gid);
+#if __BSD_VISIBLE
+int	setgroups (int ngroups, const gid_t *grouplist);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+int	sethostname (const char *, size_t);
+#endif
+int     setpgid (pid_t __pid, pid_t __pgid);
+#if __SVID_VISIBLE || __XSI_VISIBLE >= 500
+int     setpgrp (void);
+#endif
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4
+int	setregid (gid_t __rgid, gid_t __egid);
+int	setreuid (uid_t __ruid, uid_t __euid);
+#endif
+pid_t   setsid (void);
+int     setuid (uid_t __uid);
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+void	setusershell (void);
+#endif
+unsigned sleep (unsigned int __seconds);
+#if __XSI_VISIBLE
+void    swab (const void *__restrict, void *__restrict, ssize_t);
+#endif
+long    sysconf (int __name);
+pid_t   tcgetpgrp (int __fildes);
+int     tcsetpgrp (int __fildes, pid_t __pgrp_id);
+char *  ttyname (int __fildes);
+int     ttyname_r (int, char *, size_t);
+int     unlink (const char *__path);
+#if __XSI_VISIBLE >= 500 && __POSIX_VISIBLE < 200809 || __BSD_VISIBLE
+int 	usleep (useconds_t __useconds);
+#endif
+#if __BSD_VISIBLE
+int     vhangup (void);
+#endif
+_READ_WRITE_RETURN_TYPE write (int __fd, const void *__buf, size_t __nbyte);
+
+#ifdef __CYGWIN__
+# define __UNISTD_GETOPT__
+# include <getopt.h>
+# undef __UNISTD_GETOPT__
+#else
+extern char *optarg;			/* getopt(3) external variables */
+extern int optind, opterr, optopt;
+int	 getopt(int, char * const [], const char *);
+extern int optreset;			/* getopt(3) external variable */
+#endif
+
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200809)
+pid_t   vfork (void);
+#endif
+
+#ifdef _LIBC
+/* Provide prototypes for most of the _<systemcall> names that are
+   provided in newlib for some compilers.  */
+int     _close (int __fildes);
+pid_t   _fork (void);
+pid_t   _getpid (void);
+int	_isatty (int __fildes);
+int     _link (const char *__path1, const char *__path2);
+_off_t   _lseek (int __fildes, _off_t __offset, int __whence);
+#ifdef __LARGE64_FILES
+_off64_t _lseek64 (int __filedes, _off64_t __offset, int __whence);
+#endif
+_READ_WRITE_RETURN_TYPE _read (int __fd, void *__buf, size_t __nbyte);
+void *  _sbrk (ptrdiff_t __incr);
+int     _unlink (const char *__path);
+_READ_WRITE_RETURN_TYPE _write (int __fd, const void *__buf, size_t __nbyte);
+int     _execve (const char *__path, char * const __argv[], char * const __envp[]);
+int     _getentropy (void *, size_t);
+#endif
+
+#if !defined(__INSIDE_CYGWIN__)
+#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 500
+int     ftruncate (int __fd, off_t __length);
+int     ftruncate64(unsigned int, _off64_t);
+#endif
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 500
+int     truncate (const char *, off_t __length);
+int     truncate64(const char *, _off64_t);
+#endif
+#endif
+
+#if __BSD_VISIBLE || __POSIX_VISIBLE < 200112
+int	getdtablesize (void);
+#endif
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 500
+useconds_t ualarm (useconds_t __useconds, useconds_t __interval);
+#endif
+
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 500
+#if !(defined  (_WINSOCK_H) || defined (_WINSOCKAPI_) || defined (__USE_W32_SOCKETS))
+/* winsock[2].h defines as __stdcall, and with int as 2nd arg */
+ int	gethostname (char *__name, size_t __len);
+#endif
+#endif
+
+#if __MISC_VISIBLE
+int	setdtablesize (int);
+#endif
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 500
+void    sync (void);
+#endif
+
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 4
+ssize_t readlink (const char *__restrict __path,
+                          char *__restrict __buf, size_t __buflen);
+int     symlink (const char *__name1, const char *__name2);
+#endif
+#if __ATFILE_VISIBLE
+ssize_t        readlinkat (int __dirfd1, const char *__restrict __path,
+                            char *__restrict __buf, size_t __buflen);
+int	symlinkat (const char *, int, const char *);
+int	unlinkat (int, const char *, int);
+#endif
+
+#define	F_OK	0
+#define	R_OK	4
+#define	W_OK	2
+#define	X_OK	1
+
+# define	SEEK_SET	0
+# define	SEEK_CUR	1
+# define	SEEK_END	2
+#if __GNU_VISIBLE
+# define	SEEK_DATA	3
+# define	SEEK_HOLE	4
+#endif
+
+#include <sys/features.h>
+
+#define STDIN_FILENO    0       /* standard input file descriptor */
+#define STDOUT_FILENO   1       /* standard output file descriptor */
+#define STDERR_FILENO   2       /* standard error file descriptor */
+
+/*
+ *  sysconf values per IEEE Std 1003.1, 2008 Edition
+ */
+
+#define _SC_ARG_MAX                       0
+#define _SC_CHILD_MAX                     1
+#define _SC_CLK_TCK                       2
+#define _SC_NGROUPS_MAX                   3
+#define _SC_OPEN_MAX                      4
+#define _SC_JOB_CONTROL                   5
+#define _SC_SAVED_IDS                     6
+#define _SC_VERSION                       7
+#define _SC_PAGESIZE                      8
+#define _SC_PAGE_SIZE                     _SC_PAGESIZE
+/* These are non-POSIX values we accidentally introduced in 2000 without
+   guarding them.  Keeping them unguarded for backward compatibility. */
+#define _SC_NPROCESSORS_CONF              9
+#define _SC_NPROCESSORS_ONLN             10
+#define _SC_PHYS_PAGES                   11
+#define _SC_AVPHYS_PAGES                 12
+/* End of non-POSIX values. */
+#define _SC_MQ_OPEN_MAX                  13
+#define _SC_MQ_PRIO_MAX                  14
+#define _SC_RTSIG_MAX                    15
+#define _SC_SEM_NSEMS_MAX                16
+#define _SC_SEM_VALUE_MAX                17
+#define _SC_SIGQUEUE_MAX                 18
+#define _SC_TIMER_MAX                    19
+#define _SC_TZNAME_MAX                   20
+#define _SC_ASYNCHRONOUS_IO              21
+#define _SC_FSYNC                        22
+#define _SC_MAPPED_FILES                 23
+#define _SC_MEMLOCK                      24
+#define _SC_MEMLOCK_RANGE                25
+#define _SC_MEMORY_PROTECTION            26
+#define _SC_MESSAGE_PASSING              27
+#define _SC_PRIORITIZED_IO               28
+#define _SC_REALTIME_SIGNALS             29
+#define _SC_SEMAPHORES                   30
+#define _SC_SHARED_MEMORY_OBJECTS        31
+#define _SC_SYNCHRONIZED_IO              32
+#define _SC_TIMERS                       33
+#define _SC_AIO_LISTIO_MAX               34
+#define _SC_AIO_MAX                      35
+#define _SC_AIO_PRIO_DELTA_MAX           36
+#define _SC_DELAYTIMER_MAX               37
+#define _SC_THREAD_KEYS_MAX              38
+#define _SC_THREAD_STACK_MIN             39
+#define _SC_THREAD_THREADS_MAX           40
+#define _SC_TTY_NAME_MAX                 41
+#define _SC_THREADS                      42
+#define _SC_THREAD_ATTR_STACKADDR        43
+#define _SC_THREAD_ATTR_STACKSIZE        44
+#define _SC_THREAD_PRIORITY_SCHEDULING   45
+#define _SC_THREAD_PRIO_INHERIT          46
+/* _SC_THREAD_PRIO_PROTECT was _SC_THREAD_PRIO_CEILING in early drafts */
+#define _SC_THREAD_PRIO_PROTECT          47
+#define _SC_THREAD_PRIO_CEILING          _SC_THREAD_PRIO_PROTECT
+#define _SC_THREAD_PROCESS_SHARED        48
+#define _SC_THREAD_SAFE_FUNCTIONS        49
+#define _SC_GETGR_R_SIZE_MAX             50
+#define _SC_GETPW_R_SIZE_MAX             51
+#define _SC_LOGIN_NAME_MAX               52
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS 53
+#define _SC_ADVISORY_INFO                54
+#define _SC_ATEXIT_MAX                   55
+#define _SC_BARRIERS                     56
+#define _SC_BC_BASE_MAX                  57
+#define _SC_BC_DIM_MAX                   58
+#define _SC_BC_SCALE_MAX                 59
+#define _SC_BC_STRING_MAX                60
+#define _SC_CLOCK_SELECTION              61
+#define _SC_COLL_WEIGHTS_MAX             62
+#define _SC_CPUTIME                      63
+#define _SC_EXPR_NEST_MAX                64
+#define _SC_HOST_NAME_MAX                65
+#define _SC_IOV_MAX                      66
+#define _SC_IPV6                         67
+#define _SC_LINE_MAX                     68
+#define _SC_MONOTONIC_CLOCK              69
+#define _SC_RAW_SOCKETS                  70
+#define _SC_READER_WRITER_LOCKS          71
+#define _SC_REGEXP                       72
+#define _SC_RE_DUP_MAX                   73
+#define _SC_SHELL                        74
+#define _SC_SPAWN                        75
+#define _SC_SPIN_LOCKS                   76
+#define _SC_SPORADIC_SERVER              77
+#define _SC_SS_REPL_MAX                  78
+#define _SC_SYMLOOP_MAX                  79
+#define _SC_THREAD_CPUTIME               80
+#define _SC_THREAD_SPORADIC_SERVER       81
+#define _SC_TIMEOUTS                     82
+#define _SC_TRACE                        83
+#define _SC_TRACE_EVENT_FILTER           84
+#define _SC_TRACE_EVENT_NAME_MAX         85
+#define _SC_TRACE_INHERIT                86
+#define _SC_TRACE_LOG                    87
+#define _SC_TRACE_NAME_MAX               88
+#define _SC_TRACE_SYS_MAX                89
+#define _SC_TRACE_USER_EVENT_MAX         90
+#define _SC_TYPED_MEMORY_OBJECTS         91
+#define _SC_V7_ILP32_OFF32               92
+#define _SC_V6_ILP32_OFF32               _SC_V7_ILP32_OFF32
+#define _SC_XBS5_ILP32_OFF32             _SC_V7_ILP32_OFF32
+#define _SC_V7_ILP32_OFFBIG              93
+#define _SC_V6_ILP32_OFFBIG              _SC_V7_ILP32_OFFBIG
+#define _SC_XBS5_ILP32_OFFBIG            _SC_V7_ILP32_OFFBIG
+#define _SC_V7_LP64_OFF64                94
+#define _SC_V6_LP64_OFF64                _SC_V7_LP64_OFF64
+#define _SC_XBS5_LP64_OFF64              _SC_V7_LP64_OFF64
+#define _SC_V7_LPBIG_OFFBIG              95
+#define _SC_V6_LPBIG_OFFBIG              _SC_V7_LPBIG_OFFBIG
+#define _SC_XBS5_LPBIG_OFFBIG            _SC_V7_LPBIG_OFFBIG
+#define _SC_XOPEN_CRYPT                  96
+#define _SC_XOPEN_ENH_I18N               97
+#define _SC_XOPEN_LEGACY                 98
+#define _SC_XOPEN_REALTIME               99
+#define _SC_STREAM_MAX                  100
+#define _SC_PRIORITY_SCHEDULING         101
+#define _SC_XOPEN_REALTIME_THREADS      102
+#define _SC_XOPEN_SHM                   103
+#define _SC_XOPEN_STREAMS               104
+#define _SC_XOPEN_UNIX                  105
+#define _SC_XOPEN_VERSION               106
+#define _SC_2_CHAR_TERM                 107
+#define _SC_2_C_BIND                    108
+#define _SC_2_C_DEV                     109
+#define _SC_2_FORT_DEV                  110
+#define _SC_2_FORT_RUN                  111
+#define _SC_2_LOCALEDEF                 112
+#define _SC_2_PBS                       113
+#define _SC_2_PBS_ACCOUNTING            114
+#define _SC_2_PBS_CHECKPOINT            115
+#define _SC_2_PBS_LOCATE                116
+#define _SC_2_PBS_MESSAGE               117
+#define _SC_2_PBS_TRACK                 118
+#define _SC_2_SW_DEV                    119
+#define _SC_2_UPE                       120
+#define _SC_2_VERSION                   121
+#define _SC_THREAD_ROBUST_PRIO_INHERIT  122
+#define _SC_THREAD_ROBUST_PRIO_PROTECT  123
+#define _SC_XOPEN_UUCP                  124
+#define _SC_LEVEL1_ICACHE_SIZE          125
+#define _SC_LEVEL1_ICACHE_ASSOC         126
+#define _SC_LEVEL1_ICACHE_LINESIZE      127
+#define _SC_LEVEL1_DCACHE_SIZE          128
+#define _SC_LEVEL1_DCACHE_ASSOC         129
+#define _SC_LEVEL1_DCACHE_LINESIZE      130
+#define _SC_LEVEL2_CACHE_SIZE           131
+#define _SC_LEVEL2_CACHE_ASSOC          132
+#define _SC_LEVEL2_CACHE_LINESIZE       133
+#define _SC_LEVEL3_CACHE_SIZE           134
+#define _SC_LEVEL3_CACHE_ASSOC          135
+#define _SC_LEVEL3_CACHE_LINESIZE       136
+#define _SC_LEVEL4_CACHE_SIZE           137
+#define _SC_LEVEL4_CACHE_ASSOC          138
+#define _SC_LEVEL4_CACHE_LINESIZE       139
+#define _SC_POSIX_26_VERSION            140
+
+/*
+ *  pathconf values per IEEE Std 1003.1, 2008 Edition
+ */
+
+#define _PC_LINK_MAX                      0
+#define _PC_MAX_CANON                     1
+#define _PC_MAX_INPUT                     2
+#define _PC_NAME_MAX                      3
+#define _PC_PATH_MAX                      4
+#define _PC_PIPE_BUF                      5
+#define _PC_CHOWN_RESTRICTED              6
+#define _PC_NO_TRUNC                      7
+#define _PC_VDISABLE                      8
+#define _PC_ASYNC_IO                      9
+#define _PC_PRIO_IO                      10
+#define _PC_SYNC_IO                      11
+#define _PC_FILESIZEBITS                 12
+#define _PC_2_SYMLINKS                   13
+#define _PC_SYMLINK_MAX                  14
+#define _PC_ALLOC_SIZE_MIN               15
+#define _PC_REC_INCR_XFER_SIZE           16
+#define _PC_REC_MAX_XFER_SIZE            17
+#define _PC_REC_MIN_XFER_SIZE            18
+#define _PC_REC_XFER_ALIGN               19
+#define _PC_TIMESTAMP_RESOLUTION         20
+#ifdef __CYGWIN__
+/* Ask for POSIX permission bits support. */
+#define _PC_POSIX_PERMISSIONS            90
+/* Ask for full POSIX permission support including uid/gid settings. */
+#define _PC_POSIX_SECURITY               91
+#define _PC_CASE_INSENSITIVE             92
+#endif
+
+/*
+ *  confstr values per IEEE Std 1003.1, 2004 Edition
+ */
+
+/* Only defined on Cygwin and RTEMS for now. */
+#if defined (__CYGWIN__) || defined(__rtems__)
+#define _CS_PATH                               0
+#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS        1
+#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS       _CS_POSIX_V7_ILP32_OFF32_CFLAGS
+#define _CS_XBS5_ILP32_OFF32_CFLAGS           _CS_POSIX_V7_ILP32_OFF32_CFLAGS
+#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS       2
+#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS      _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
+#define _CS_XBS5_ILP32_OFF32_LDFLAGS          _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
+#define _CS_POSIX_V7_ILP32_OFF32_LIBS          3
+#define _CS_POSIX_V6_ILP32_OFF32_LIBS         _CS_POSIX_V7_ILP32_OFF32_LIBS
+#define _CS_XBS5_ILP32_OFF32_LIBS             _CS_POSIX_V7_ILP32_OFF32_LIBS
+#define _CS_XBS5_ILP32_OFF32_LINTFLAGS         4
+#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS       5
+#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS      _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
+#define _CS_XBS5_ILP32_OFFBIG_CFLAGS          _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
+#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS      6
+#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS     _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
+#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS         _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
+#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS         7
+#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS        _CS_POSIX_V7_ILP32_OFFBIG_LIBS
+#define _CS_XBS5_ILP32_OFFBIG_LIBS            _CS_POSIX_V7_ILP32_OFFBIG_LIBS
+#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS        8
+#define _CS_POSIX_V7_LP64_OFF64_CFLAGS         9
+#define _CS_POSIX_V6_LP64_OFF64_CFLAGS        _CS_POSIX_V7_LP64_OFF64_CFLAGS
+#define _CS_XBS5_LP64_OFF64_CFLAGS            _CS_POSIX_V7_LP64_OFF64_CFLAGS
+#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS       10
+#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS       _CS_POSIX_V7_LP64_OFF64_LDFLAGS
+#define _CS_XBS5_LP64_OFF64_LDFLAGS           _CS_POSIX_V7_LP64_OFF64_LDFLAGS
+#define _CS_POSIX_V7_LP64_OFF64_LIBS          11
+#define _CS_POSIX_V6_LP64_OFF64_LIBS          _CS_POSIX_V7_LP64_OFF64_LIBS
+#define _CS_XBS5_LP64_OFF64_LIBS              _CS_POSIX_V7_LP64_OFF64_LIBS
+#define _CS_XBS5_LP64_OFF64_LINTFLAGS         12
+#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS      13
+#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS      _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
+#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS          _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS     14
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS     _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
+#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS         _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS        15
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS        _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
+#define _CS_XBS5_LPBIG_OFFBIG_LIBS            _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
+#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS       16
+#define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS    17
+#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS    _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
+#define _CS_XBS5_WIDTH_RESTRICTED_ENVS        _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
+#define _CS_POSIX_V7_THREADS_CFLAGS           18
+#define _CS_POSIX_V7_THREADS_LDFLAGS          19
+#define _CS_V7_ENV                            20
+#define _CS_V6_ENV                            _CS_V7_ENV
+#define _CS_LFS_CFLAGS                        21
+#define _CS_LFS_LDFLAGS                       22
+#define _CS_LFS_LIBS                          23
+#define _CS_LFS_LINTFLAGS                     24
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#if __SSP_FORTIFY_LEVEL > 0
+#include <ssp/unistd.h>
+#endif
+
+#endif /* _SYS_UNISTD_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ustat.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ustat.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/ustat.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/ustat.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,32 @@
+/* Header describing obsolete `ustat' interface.
+   Copyright (C) 1996, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * This interface is obsolete.  Use <sys/statfs.h> instead.
+ */
+
+#ifndef _SYS_USTAT_H
+#define	_SYS_USTAT_H	1
+
+#include <sys/types.h>
+#include <bits/ustat.h>
+
+extern int ustat (__dev_t __dev, struct ustat *__ubuf);
+
+#endif /* sys/ustat.h */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/utime.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/utime.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/utime.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/utime.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,22 @@
+#ifndef _SYS_UTIME_H
+#define _SYS_UTIME_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/_timeval.h>
+
+struct utimbuf 
+{
+  time_t actime;
+  time_t modtime; 
+};
+
+int utime(const char *, const struct utimbuf *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_UTIME_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/utmp.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/utmp.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/utmp.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/utmp.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,76 @@
+/* libc/sys/linux/sys/utmp.h - utmp structure */
+
+/* Written 2000 by Werner Almesberger */
+
+
+/* Some things copied from glibc's /usr/include/bits/utmp.h */
+
+
+#ifndef _SYS_UTMP_H
+#define _SYS_UTMP_H
+
+
+#include <paths.h>
+#include <sys/types.h>
+#include <sys/time.h>
+
+
+/* compatibility names for the strings of the canonical file names */
+#define UTMP_FILE	_PATH_UTMP
+#define WTMP_FILE	_PATH_WTMP
+
+#define UT_LINESIZE	32
+#define UT_NAMESIZE	32
+#define UT_HOSTSIZE	256
+
+/*
+ * The structure describing the status of a terminated process.
+ * This type is used in `struct utmp' below.
+ */
+struct exit_status {
+	short int e_termination;	/* Process termination status.  */
+	short int e_exit;		/* Process exit status.  */
+};
+
+struct utmp {
+    short int ut_type;
+    pid_t ut_pid;
+    char ut_line[UT_LINESIZE];
+    char ut_id[4];
+    char ut_user[UT_NAMESIZE];
+    char ut_host[UT_HOSTSIZE];
+    struct exit_status ut_exit;	/* Exit status of a process marked
+    				   as DEAD_PROCESS.  */
+    struct timeval ut_tv;		/* Time entry was made.  */
+    char __filler[44];
+};
+
+/* Backwards compatibility hacks.  */
+#define ut_name		ut_user
+#define ut_time		ut_tv.tv_sec
+
+
+#define RUN_LVL		1
+#define BOOT_TIME	2
+#define NEW_TIME	3
+#define OLD_TIME	4
+
+#define INIT_PROCESS	5
+#define LOGIN_PROCESS	6
+#define USER_PROCESS	7
+#define DEAD_PROCESS	8
+
+
+/* --- redundant, from sys/cygwin/sys/utmp.h --- */
+
+struct utmp *_getutline (struct utmp *);
+struct utmp *getutent (void);
+struct utmp *getutid (struct utmp *);
+struct utmp *getutline (struct utmp *);
+void endutent (void);
+void pututline (struct utmp *);
+void setutent (void);
+void utmpname (const char *);
+int updwtmp(char *, struct utmp *);
+
+#endif /* _SYS_UTMP_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/utsname.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/utsname.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/utsname.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/utsname.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,85 @@
+/* Copyright (C) 1991, 1992, 1994, 1996 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * fiwix/include/sys/utsname.h
+ *
+ * Copyright 2018-2022, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#ifndef _FIWIX_UTSNAME_H
+#define _FIWIX_UTSNAME_H
+
+#define _OLD_UTSNAME_LENGTH	8
+#define _UTSNAME_LENGTH		64
+
+#ifndef _UTSNAME_NODENAME_LENGTH
+#define _UTSNAME_NODENAME_LENGTH _UTSNAME_LENGTH
+#endif
+
+/* very old structure describing the system and machine */
+struct oldold_utsname
+{
+    char sysname[_OLD_UTSNAME_LENGTH + 1];
+    char nodename[_OLD_UTSNAME_LENGTH + 1];
+    char release[_OLD_UTSNAME_LENGTH + 1];
+    char version[_OLD_UTSNAME_LENGTH + 1];
+    char machine[_OLD_UTSNAME_LENGTH + 1];
+};
+
+/* old structure describing the system and machine */
+struct old_utsname
+{
+    char sysname[_UTSNAME_LENGTH + 1];
+    char nodename[_UTSNAME_NODENAME_LENGTH + 1];
+    char release[_UTSNAME_LENGTH + 1];
+    char version[_UTSNAME_LENGTH + 1];
+    char machine[_UTSNAME_LENGTH + 1];
+};
+
+/* new structure describing the system and machine */
+struct utsname
+{
+    /* name of this implementation of the operating system */
+    char sysname[_UTSNAME_LENGTH + 1];
+
+    /* name of this node on the network */
+    char nodename[_UTSNAME_NODENAME_LENGTH + 1];
+
+    /* current release level of this implementation */
+    char release[_UTSNAME_LENGTH + 1];
+    /* current version level of this release */
+    char version[_UTSNAME_LENGTH + 1];
+
+    /* name of the hardware type on which the system is running */
+    char machine[_UTSNAME_LENGTH + 1];
+    char domainname[_UTSNAME_LENGTH + 1];
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int uname(struct utsname *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FIWIX_UTSNAME_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/vfs.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/vfs.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/sys/vfs.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/sys/vfs.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,9 @@
+#ifndef _SYS_VFS_H
+#define _SYS_VFS_H
+
+#include <sys/statfs.h>
+
+//extern int statfs(const char *, struct statfs *);
+//int	statfs(const char * __path, struct statfs * __buf);
+
+#endif /* _SYS_VFS_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/syscalls.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/syscalls.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/syscalls.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/syscalls.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,1044 @@
+/*
+ * fiwix/syscalls.c
+ *
+ * Copyright 2018-2022, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <sys/errno.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/fcntl.h>
+#include <sys/times.h>
+#include <sys/time.h>
+#include <sys/timeb.h>
+#include <sys/resource.h>
+#include <sys/mman.h>
+#include <sys/dirent.h>
+#include <sys/ustat.h>
+#include <sys/utime.h>
+#include <sys/utsname.h>
+#include <sys/statfs.h>
+#include <sys/select.h>
+#include <sys/sysinfo.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <signal.h>
+#include <stdio.h>
+ 
+#include "syscalls.h"
+#include "sockops.h"
+
+char **environ;
+char **__argv;
+char *__progname;
+
+SYSCALL1(exit, retval, int);
+SYSCALL0(fork, retval);
+SYSCALL3(read, retval, int, void *, size_t);
+SYSCALL3(write, retval, int, const void *, size_t);
+SYSCALL3(open, retval, const char *, int, mode_t);
+SYSCALL1(close, retval, int);
+SYSCALL3(waitpid, retval, pid_t, int *, int);
+SYSCALL2(creat, retval, const char *, mode_t);
+SYSCALL2(link, retval, const char *, const char *);
+SYSCALL1(unlink, retval, const char *);
+SYSCALL3(execve, retval, const char *, const char **, const char **);
+SYSCALL1(chdir, retval, const char *);
+SYSCALL1(time, retval, time_t *);
+SYSCALL3(mknod, retval, const char *, mode_t, dev_t);
+SYSCALL2(chmod, retval, const char *, mode_t);
+SYSCALL3(lchown, retval, const char *, uid_t, gid_t);
+// unused (break)
+SYSCALL2(oldstat, retval, const char *, struct old_stat *);
+SYSCALL3(lseek, retval, int, off_t, int);
+SYSCALL0(getpid, retval);
+SYSCALL5(mount, retval, const char *, const char *, const char *, unsigned int, const void *);
+SYSCALL1(umount, retval, const char *);
+SYSCALL1(setuid, retval, uid_t);
+SYSCALL0(getuid, retval);
+SYSCALL1(stime, retval, time_t *);
+// unused (ptrace)
+SYSCALL1(alarm, retval, int);
+SYSCALL2(oldfstat, retval, int, struct old_stat *);
+SYSCALL0(pause, retval);
+SYSCALL2(utime, retval, const char *, const struct utimbuf *);
+// unused (stty)
+// unused (gtty)
+SYSCALL2(access, retval, const char *, int);
+// nice
+SYSCALL1(ftime, retval, struct timeb *);
+SYSCALL0(sync, retval);
+SYSCALL2(kill, retval, int, int);
+SYSCALL2(rename, retval, const char *, const char *);
+SYSCALL2(mkdir, retval, const char *, mode_t);
+SYSCALL1(rmdir, retval, const char *);
+SYSCALL1(dup,retval, unsigned int);
+SYSCALL1(pipe, retval, int *);
+SYSCALL1(times, retval, struct tms *);
+// unused (prof)
+SYSCALL1(brk, retval, unsigned int);
+SYSCALL1(setgid, retval, gid_t);
+SYSCALL0(getgid, retval);
+SYSCALL2(signal, retval, int, __sighandler_t);
+SYSCALL0(geteuid, retval);
+SYSCALL0(getegid, retval);
+// acct
+SYSCALL2(umount2, retval, const char *, int);
+// unused (lock)
+SYSCALL3(ioctl, retval, unsigned int, int, unsigned int);
+SYSCALL3(fcntl, retval, int, int, unsigned int);
+// unused (mpx)
+SYSCALL2(setpgid, retval, pid_t, pid_t);
+// unused (ulimit)
+SYSCALL1(olduname, retval, struct oldold_utsname *);
+SYSCALL1(umask, retval, mode_t);
+SYSCALL1(chroot, retval, const char *);
+SYSCALL2(ustat, retval, dev_t, struct ustat *);
+SYSCALL2(dup2, retval, unsigned int, unsigned int);
+SYSCALL0(getppid, retval);
+SYSCALL0(getpgrp, retval);
+SYSCALL0(setsid, retval);
+SYSCALL3(sigaction, retval, int, const struct sigaction *, struct sigaction *);
+SYSCALL0(sgetmask, retval);
+SYSCALL1(ssetmask, retval, unsigned int);
+SYSCALL2(setreuid, retval, uid_t, uid_t);
+SYSCALL2(setregid, retval, gid_t, gid_t);
+SYSCALL1(sigsuspend, retval, const sigset_t *);
+SYSCALL1(sigpending, retval, sigset_t *);
+SYSCALL2(sethostname, retval, const char *, size_t);
+SYSCALL2(setrlimit, retval, int, const struct rlimit *);
+SYSCALL2(getrlimit, retval, int, struct rlimit *);
+SYSCALL2(getrusage, retval, int, struct rusage *);
+SYSCALL2(gettimeofday, retval, struct timeval *, struct timezone *);
+SYSCALL2(settimeofday, retval, const struct timeval *, const struct timezone *);
+SYSCALL2(getgroups, retval, int, gid_t *);
+SYSCALL2(setgroups, retval, size_t, const gid_t *);
+SYSCALL1(oldselect, retval, int *);
+SYSCALL2(symlink, retval, const char *, const char *);
+SYSCALL2(oldlstat, retval, const char *, struct old_stat *);
+SYSCALL3(readlink, retval, const char *, char *, size_t);
+// uselib
+// swapon
+SYSCALL3(reboot, retval, int, int, int);
+// old_readdir
+SYSCALL1(old_mmap, retval, struct mmap *);
+SYSCALL2(munmap, retval, void *, size_t);
+SYSCALL2(truncate, retval, const char *, off_t);
+SYSCALL2(ftruncate, retval, int, off_t);
+SYSCALL2(fchmod, retval, int, mode_t);
+SYSCALL3(fchown, retval, int, uid_t, gid_t);
+// getpriority
+// setpriority
+SYSCALL2(statfs, retval, const char *, struct statfs *);
+SYSCALL2(fstatfs, retval, int, struct statfs *);
+SYSCALL3(ioperm, retval, unsigned int, unsigned int, int);
+SYSCALL2(socketcall, retval, int, unsigned int *);
+// syslog
+SYSCALL3(setitimer, retval, int, const struct itimerval *, struct itimerval *);
+SYSCALL2(getitimer, retval, int, struct itimerval *);
+SYSCALL2(newstat, retval, const char *, struct stat *);
+SYSCALL2(newlstat, retval, const char *, struct stat *);
+SYSCALL2(newfstat, retval, int, struct stat *);
+SYSCALL1(uname, retval, struct old_utsname *);
+SYSCALL1(iopl, retval, int);
+// vhangup
+// unused (idle)
+// vm86old
+SYSCALL4(wait4, retval, pid_t, int *, int, struct rusage *);
+// swapoff
+SYSCALL1(sysinfo, retval, struct sysinfo *);
+SYSCALL2(ipc, retval, unsigned int, struct sysvipc_args *);
+SYSCALL1(fsync, retval, int);
+SYSCALL1(sigreturn, retval, int);
+// clone
+SYSCALL2(setdomainname, retval, const char *, size_t);
+SYSCALL1(newuname, retval, struct utsname *);
+// modify_ldt
+// adjtimex
+SYSCALL3(mprotect, retval, void *, size_t, int);
+SYSCALL3(sigprocmask, retval, int, const sigset_t *, sigset_t *);
+// create_module
+// init_module
+// delete_module
+// get_kernel_syms
+// quotactl
+SYSCALL1(getpgid, retval, pid_t);
+SYSCALL1(fchdir, retval, int);
+// bdflush
+// sysfs
+SYSCALL1(personality, retval, int);
+// afs
+// setfsuid
+// setfsgid
+SYSCALL5(llseek, retval, int, off_t, off_t, __loff_t *, unsigned int);
+SYSCALL3(getdents, retval, unsigned int, struct dirent *, unsigned int);
+SYSCALL5(select, retval, int, fd_set *, fd_set *, fd_set *, struct timeval *);
+SYSCALL2(flock, retval, int, int);
+SYSCALL3(readv, retval, int, const struct iovec *, int);
+SYSCALL3(writev, retval, int, const struct iovec *, int);
+SYSCALL1(getsid, retval, pid_t);
+SYSCALL1(fdatasync, retval, int);
+// sysctl
+// mlock
+// munlock
+// mlockall
+// munlockall
+//
+// ...
+SYSCALL2(nanosleep, retval, const struct timespec *, struct timespec *);
+//
+// ...
+SYSCALL3(chown, retval, const char *, uid_t, gid_t);
+SYSCALL2(getcwd, retval, char *, size_t);
+//
+// ...
+SYSCALL0(vfork, retval);
+//
+SYSCALL6(mmap2, retval, unsigned int, unsigned int, unsigned int, unsigned int, int, unsigned int);
+SYSCALL3(truncate64, retval, const char *, off_t, off_t);
+SYSCALL3(ftruncate64, retval, unsigned int, off_t, off_t);
+SYSCALL2(stat64, retval, const char *, struct stat64 *);
+SYSCALL2(lstat64, retval, const char *, struct stat64 *);
+SYSCALL2(fstat64, retval, unsigned int, struct stat64 *);
+//
+// ...
+SYSCALL3(chown32, retval, const char *, unsigned int, unsigned int);
+//
+#ifdef __LARGE64_FILES
+SYSCALL3(getdents64, retval, unsigned int, struct dirent64 *, unsigned int);
+#endif /* __LARGE64_FILES */
+SYSCALL3(fcntl64, retval, unsigned int, int, unsigned int);
+//
+SYSCALL2(utimes, retval, const char *, const struct timeval *);
+
+
+void _exit(int status)
+{
+	__sys_exit(status);
+	for(;;);
+}
+
+int fork(void)
+{
+	return __sys_fork();
+}
+
+int read(int fd, void *buf, size_t count)
+{
+	return __sys_read(fd, buf, count);
+}
+
+int write(int fd, const void *buf, size_t count)
+{
+	return __sys_write(fd, buf, count);
+}
+
+int __open(const char *pathname, int flags, mode_t mode)
+{
+	return __sys_open(pathname, flags, mode);
+}
+
+int close(int fd)
+{
+	return __sys_close(fd);
+}
+
+int waitpid(pid_t pid, int *status, int options)
+{
+	return __sys_waitpid(pid, status, options);
+}
+
+/*
+int creat(const char *pathname, mode_t mode)
+{
+	return __sys_creat(pathname, mode);
+}
+*/
+
+int link(const char *oldpath, const char *newpath)
+{
+	return __sys_link(oldpath, newpath);
+}
+
+int unlink(const char *pathname)
+{
+	return __sys_unlink(pathname);
+}
+
+int _execve(const char *name, const char **argv, const char **envp)
+{
+	return __sys_execve(name, argv, envp);
+}
+
+int chdir(const char *path)
+{
+	return __sys_chdir(path);
+}
+
+int mknod(const char *pathname, mode_t mode, dev_t dev)
+{
+	return __sys_mknod(pathname, mode, dev);
+}
+
+int chmod(const char *path, mode_t mode)
+{
+	return __sys_chmod(path, mode);
+}
+
+int lchown(const char *path, uid_t owner, gid_t group)
+{
+	return __sys_lchown(path, owner, group);
+}
+
+int old_stat(const char *path, struct old_stat *buf)
+{
+	return __sys_oldstat(path, buf);
+}
+
+int lseek(int fd, off_t offset, int whence)
+{
+	return __sys_lseek(fd, offset, whence);
+}
+
+int getpid(void)
+{
+	return __sys_getpid();
+}
+
+int mount(const char *source, const char *target, const char *fstype, unsigned int flags, const void *data)
+{
+	return __sys_mount(source, target, fstype, flags, data);
+}
+
+int umount(const char *target)
+{
+	return __sys_umount(target);
+}
+
+int setuid(uid_t uid)
+{
+	return __sys_setuid(uid);
+}
+
+uid_t getuid(void)
+{
+	return __sys_getuid();
+}
+
+int stime(time_t *t)
+{
+	return __sys_stime(t);
+}
+
+int alarm(unsigned int seconds)
+{
+	return __sys_alarm(seconds);
+}
+
+int old_fstat(int fd, struct old_stat *buf)
+{
+	return __sys_oldfstat(fd, buf);
+}
+
+int pause(void)
+{
+	return __sys_pause();
+}
+
+int utime(const char *filename, const struct utimbuf *times)
+{
+	return __sys_utime(filename, times);
+}
+
+int access(const char *pathname, int mode)
+{
+	return __sys_access(pathname, mode);
+}
+
+int ftime(struct timeb *tp)
+{
+	return __sys_ftime(tp);
+}
+
+void sync(void)
+{
+	return (void)__sys_sync();
+}
+
+int kill(int pid, int signal)
+{
+	return __sys_kill(pid, signal);
+}
+
+int __rename(const char *old, const char *new)
+{
+	return __sys_rename(old, new);
+}
+
+int mkdir(const char *pathname, mode_t mode)
+{
+	return __sys_mkdir(pathname, mode);
+}
+
+int rmdir(const char *pathname)
+{
+	return __sys_rmdir(pathname);
+}
+
+int dup(unsigned int oldfd)
+{
+	return __sys_dup(oldfd);
+}
+
+int pipe(int *pipefd)
+{
+	return __sys_pipe(pipefd);
+}
+
+clock_t times(struct tms *buf)
+{
+	return __sys_times(buf);
+}
+
+int __brk(void *addr)
+{
+	return __sys_brk((unsigned int)addr);
+}
+
+int setgid(gid_t gid)
+{
+	return __sys_setgid(gid);
+}
+
+gid_t getgid(void)
+{
+	return __sys_getgid();
+}
+
+__sighandler_t signal(int signum, __sighandler_t sighandler)
+{
+	return (__sighandler_t)__sys_signal(signum, sighandler);
+}
+
+uid_t geteuid(void)
+{
+	return __sys_geteuid();
+}
+
+gid_t getegid(void)
+{
+	return __sys_getegid();
+}
+
+int umount2(const char *target, int flags)
+{
+	return __sys_umount2(target, flags);
+}
+
+int ioctl(unsigned int fd, int cmd, unsigned int arg)
+{
+	return __sys_ioctl(fd, cmd, arg);
+}
+
+int __fcntl(int fd, int cmd, unsigned int arg)
+{
+	return __sys_fcntl(fd, cmd, arg);
+}
+
+int setpgid(pid_t pid, pid_t pgid)
+{
+	return __sys_setpgid(pid, pgid);
+}
+
+int oldold_uname(struct oldold_utsname *buf)
+{
+	return __sys_olduname(buf);
+}
+
+mode_t umask(mode_t mask)
+{
+	return __sys_umask(mask);
+}
+
+int chroot(const char *path)
+{
+	return __sys_chroot(path);
+}
+
+int ustat(dev_t dev, struct ustat *ubuf)
+{
+	return __sys_ustat(dev, ubuf);
+}
+
+int dup2(unsigned int oldfd, unsigned int newfd)
+{
+	return __sys_dup2(oldfd, newfd);
+}
+
+int getppid(void)
+{
+	return __sys_getppid();
+}
+
+int getpgrp(void)
+{
+	return __sys_getpgrp();
+}
+
+pid_t setsid(void)
+{
+	return __sys_setsid();
+}
+
+int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
+{
+	return __sys_sigaction(signum, act, oldact);
+}
+
+int sgetmask(void)
+{
+	return __sys_sgetmask();
+}
+
+int ssetmask(unsigned int newmask)
+{
+	return __sys_ssetmask(newmask);
+}
+
+int setreuid(uid_t ruid, uid_t euid)
+{
+	return __sys_setreuid(ruid, euid);
+}
+
+int setregid(gid_t rgid, gid_t egid)
+{
+	return __sys_setregid(rgid, egid);
+}
+
+int sigsuspend(const sigset_t *mask)
+{
+	return __sys_sigsuspend(mask);
+}
+
+int sigpending(sigset_t *set)
+{
+	return __sys_sigpending(set);
+}
+
+int sethostname(const char *name, size_t len)
+{
+	return __sys_sethostname(name, len);
+}
+
+int setrlimit(int resource, const struct rlimit *rlim)
+{
+	return __sys_setrlimit(resource, rlim);
+}
+
+int getrlimit(int resource, struct rlimit *rlim)
+{
+	return __sys_getrlimit(resource, rlim);
+}
+
+int getrusage(int who, struct rusage *usage)
+{
+	return __sys_getrusage(who, usage);
+}
+
+int gettimeofday(struct timeval *tv, void *tz)
+{
+	return __sys_gettimeofday(tv, (struct timezone *)tz);
+}
+
+int settimeofday(const struct timeval *tv, const struct timezone *tz)
+{
+	return __sys_settimeofday(tv, tz);
+}
+
+int getgroups(int size, gid_t *list)
+{
+	return __sys_getgroups(size, list);
+}
+
+int setgroups(int size, const gid_t *list)
+{
+	return __sys_setgroups(size, list);
+}
+
+int old_select(int *params)
+{
+	return __sys_oldselect(params);
+}
+
+int symlink(const char *oldpath, const char *newpath)
+{
+	return __sys_symlink(oldpath, newpath);
+}
+
+int old_lstat(const char *path, struct old_stat *buf)
+{
+	return __sys_oldlstat(path, buf);
+}
+
+ssize_t readlink(const char *path, char *buf, size_t bufsiz)
+{
+	return __sys_readlink(path, buf, bufsiz);
+}
+
+int reboot(int magic1, int magic2, int cmd)
+{
+	return __sys_reboot(magic1, magic2, cmd);
+}
+
+int old_mmap(struct mmap *mmap)
+{
+	return __sys_old_mmap(mmap);
+}
+
+int munmap(void *addr, size_t length)
+{
+	return __sys_munmap(addr, length);
+}
+
+int truncate(const char *path, off_t length)
+{
+	return __sys_truncate(path, length);
+}
+
+int ftruncate(int fd, off_t length)
+{
+	return __sys_ftruncate(fd, length);
+}
+
+int fchmod(int fd, mode_t mode)
+{
+	return __sys_fchmod(fd, mode);
+}
+
+int fchown(int fd, uid_t owner, gid_t group)
+{
+	return __sys_fchown(fd, owner, group);
+}
+
+int statfs(const char *path, struct statfs *buf)
+{
+	return __sys_statfs(path, buf);
+}
+
+int fstatfs(int fd, struct statfs *buf)
+{
+	return __sys_fstatfs(fd, buf);
+}
+
+int ioperm(unsigned int from, unsigned int num, int turn_on)
+{
+	return __sys_ioperm(from, num, turn_on);
+}
+
+int socketcall(int call, unsigned int *args)
+{
+	return __sys_socketcall(call, args);
+}
+
+int socket(int domain, int type, int protocol)
+{
+	unsigned int args[3];
+
+	args[0] = domain;
+	args[1] = type;
+	args[2] = protocol;
+
+	return socketcall(SYS_SOCKET, &args[0]);
+}
+
+int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
+{
+	unsigned int args[3];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)addr;
+	args[2] = addrlen;
+
+	return socketcall(SYS_BIND, &args[0]);
+}
+
+int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
+{
+	unsigned int args[3];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)addr;
+	args[2] = addrlen;
+
+	return socketcall(SYS_CONNECT, &args[0]);
+}
+
+int listen(int sockfd, int backlog)
+{
+	unsigned int args[2];
+
+	args[0] = sockfd;
+	args[1] = backlog;
+
+	return socketcall(SYS_LISTEN, &args[0]);
+}
+
+int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
+{
+	unsigned int args[3];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)addr;
+	args[2] = (unsigned int)addrlen;
+
+	return socketcall(SYS_ACCEPT, &args[0]);
+}
+
+int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
+{
+	unsigned int args[3];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)addr;
+	args[2] = (unsigned int)addrlen;
+
+	return socketcall(SYS_GETSOCKNAME, &args[0]);
+}
+
+int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
+{
+	unsigned int args[3];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)addr;
+	args[2] = (unsigned int)addrlen;
+
+	return socketcall(SYS_GETPEERNAME, &args[0]);
+}
+
+int socketpair(int domain, int type, int protocol, int sv[2])
+{
+	unsigned int args[4];
+
+	args[0] = domain;
+	args[1] = type;
+	args[2] = protocol;
+	args[3] = (unsigned int)&sv[0];
+
+	return socketcall(SYS_SOCKETPAIR, &args[0]);
+}
+
+ssize_t send(int sockfd, const void *buf, size_t len, int flags)
+{
+	unsigned int args[4];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)buf;
+	args[2] = len;
+	args[3] = flags;
+
+	return socketcall(SYS_SEND, &args[0]);
+}
+
+ssize_t recv(int sockfd, void *buf, size_t len, int flags)
+{
+	unsigned int args[4];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)buf;
+	args[2] = len;
+	args[3] = flags;
+
+	return socketcall(SYS_RECV, &args[0]);
+}
+
+ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)
+{
+	unsigned int args[6];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)buf;
+	args[2] = len;
+	args[3] = flags;
+	args[4] = (unsigned int)dest_addr;
+	args[5] = addrlen;
+
+	return socketcall(SYS_SENDTO, &args[0]);
+}
+
+ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)
+{
+	unsigned int args[6];
+
+	args[0] = sockfd;
+	args[1] = (unsigned int)buf;
+	args[2] = len;
+	args[3] = flags;
+	args[4] = (unsigned int)src_addr;
+	args[5] = (unsigned int)addrlen;
+
+	return socketcall(SYS_RECVFROM, &args[0]);
+}
+
+int shutdown(int sockfd, int how)
+{
+	unsigned int args[2];
+
+	args[0] = sockfd;
+	args[1] = how;
+
+	return socketcall(SYS_SHUTDOWN, &args[0]);
+}
+
+int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)
+{
+	unsigned int args[5];
+
+	args[0] = sockfd;
+	args[1] = level;
+	args[2] = optname;
+	args[3] = (unsigned int)optval;
+	args[4] = optlen;
+
+	return socketcall(SYS_SETSOCKOPT, &args[0]);
+}
+
+int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen)
+{
+	unsigned int args[5];
+
+	args[0] = sockfd;
+	args[1] = level;
+	args[2] = optname;
+	args[3] = (unsigned int)optval;
+	args[4] = (unsigned int)optlen;
+
+	return socketcall(SYS_GETSOCKOPT, &args[0]);
+}
+
+int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)
+{
+	return __sys_setitimer(which, new_value, old_value);
+}
+
+int getitimer(int which, struct itimerval *curr_value)
+{
+	return __sys_getitimer(which, curr_value);
+}
+
+int stat(const char *path, struct stat *buf)
+{
+	return __sys_newstat(path, buf);
+}
+
+int lstat(const char *path, struct stat *st)
+{
+	return __sys_newlstat(path, st);
+}
+
+int fstat(int fd, struct stat *st)
+{
+	return __sys_newfstat(fd, st);
+}
+
+int old_uname(struct old_utsname *buf)
+{
+	return __sys_uname(buf);
+}
+
+int iopl(int level)
+{
+	return __sys_iopl(level);
+}
+
+int wait4(pid_t pid, int *status, int options, struct rusage *rusage)
+{
+	return __sys_wait4(pid, status, options, rusage);
+}
+
+int sysinfo(struct sysinfo *info)
+{
+	return __sys_sysinfo(info);
+}
+
+int ipc(unsigned int call, struct sysvipc_args *args)
+{
+	return __sys_ipc(call, args);
+}
+
+int fsync(int fd)
+{
+	return __sys_fsync(fd);
+}
+
+int sigreturn(int unused)
+{
+	return __sys_sigreturn(unused);
+}
+
+int setdomainname(const char *name, size_t len)
+{
+	return __sys_setdomainname(name, len);
+}
+
+int uname(struct utsname *buf)
+{
+	return __sys_newuname(buf);
+}
+
+int mprotect(void *addr, size_t len, int prot)
+{
+	return __sys_mprotect(addr, len, prot);
+}
+
+int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
+{
+	return __sys_sigprocmask(how, set, oldset);
+}
+
+int getpgid(pid_t pid)
+{
+	return __sys_getpgid(pid);
+}
+
+int fchdir(int fd)
+{
+	return __sys_fchdir(fd);
+}
+
+int personality(int persona)
+{
+	return __sys_personality(persona);
+}
+
+int llseek(int fd, off_t offset_high, off_t offset_low, __loff_t *result, unsigned int whence)
+{
+	return __sys_llseek(fd, offset_high, offset_low, result, whence);
+}
+
+int getdents(unsigned int fd, struct dirent *dirp, unsigned int count)
+{
+	return __sys_getdents(fd, dirp, count);
+}
+
+int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
+{
+	return __sys_select(nfds, readfds, writefds, exceptfds, timeout);
+}
+
+int flock(int fd, int operation)
+{
+	return __sys_flock(fd, operation);
+}
+
+ssize_t readv(int fd, const struct iovec *iov, int iovcnt)
+{
+	return __sys_readv(fd, iov, iovcnt);
+}
+
+ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
+{
+	return __sys_writev(fd, iov, iovcnt);
+}
+
+int getsid(pid_t pid)
+{
+	return __sys_getsid(pid);
+}
+
+int fdatasync(int fd)
+{
+	return __sys_fdatasync(fd);
+}
+
+int nanosleep(const struct timespec *req, struct timespec *rem)
+{
+	return __sys_nanosleep(req, rem);
+}
+
+int chown(const char *path, uid_t owner, gid_t group)
+{
+	/* return __sys_chown(path, owner, group); */
+
+	int __err;
+
+	/*
+	 * In Fiwix 1.5.0, the old sys_chown (#16) was renamed to
+	 * sys_lchown, and the new sys_chown was moved to #182, breaking
+	 * binary compatibility with Linux 2.0.
+	 *
+	 * The following keeps compatibility with Linux 2.0.
+	 */
+	__err = __sys_chown(path, owner, group);
+	if(__err < 0 && errno == ENOSYS) {
+		__err = __sys_lchown(path, owner, group);
+	}
+
+	return __err;
+}
+
+int vfork(void)
+{
+	return __sys_fork();
+}
+
+void *mmap2(void *addr, size_t len, int prot, int flags, int fd, off_t offset)
+{
+	return (void *)__sys_mmap2((unsigned int)addr, len, prot, flags, fd, offset);
+}
+
+int truncate64(const char *path, __loff_t length)
+{
+	unsigned int low, high;
+
+	low = length & 0xFFFFFFFF;
+	high = length >> 32;
+	return __sys_truncate64(path, low, high);
+}
+
+int ftruncate64(unsigned int fd, __loff_t length)
+{
+	unsigned int low, high;
+
+	low = length & 0xFFFFFFFF;
+	high = length >> 32;
+	return __sys_ftruncate64(fd, low, high);
+}
+
+int stat64(const char *path, struct stat64 *buf)
+{
+	return __sys_stat64(path, buf);
+}
+
+int lstat64(const char *path, struct stat64 *buf)
+{
+	return __sys_lstat64(path, buf);
+}
+
+int fstat64(unsigned int fd, struct stat64 *buf)
+{
+	return __sys_fstat64(fd, buf);
+}
+
+int chown32(const char *path, unsigned int owner, unsigned int group)
+{
+	return __sys_chown32(path, owner, group);
+}
+
+#ifdef __LARGE64_FILES
+ssize_t getdents64(unsigned int fd, struct dirent64 *dirp, unsigned int count)
+{
+	return __sys_getdents64(fd, dirp, count);
+}
+#endif /* __LARGE64_FILES */
+
+int fcntl64(unsigned int fd, int cmd, unsigned int arg)
+{
+	return __sys_fcntl64(fd, cmd, arg);
+}
+
+int utimes(const char *filename, const struct timeval times[2])
+{
+	return __sys_utimes(filename, times);
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/syscalls.h newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/syscalls.h
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/syscalls.h	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/syscalls.h	2025-01-31 08:25:59 +0000
@@ -0,0 +1,175 @@
+/*
+ * fiwix/syscalls.h
+ *
+ * Copyright 2018-2022, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#ifndef _SYSCALLS_H
+#define _SYSCALLS_H
+
+#include <fiwix/unistd.h>
+
+#define MAXERRNO	-125
+
+struct sysvipc_args {
+	int arg1;
+	int arg2;
+	int arg3;
+	void *ptr;
+	int arg5;
+};
+
+#define SYSCALL0(fn, retval)					\
+	int __sys_##fn(void)					\
+	{							\
+		unsigned int retval;				\
+								\
+		__asm__ __volatile__(				\
+			"int	$0x80\n\t"			\
+			: "=a"(retval)				\
+			: "0"(SYS_##fn)				\
+		);						\
+		if((int)retval < 0 && (int)retval > MAXERRNO) {	\
+			errno = -(retval);			\
+			retval = -1;				\
+			return (int)retval;			\
+		}						\
+		return retval;					\
+	}
+
+#define SYSCALL1(fn, retval, type1)				\
+	int __sys_##fn(type1 arg1)				\
+	{							\
+		unsigned int retval;				\
+								\
+		__asm__ __volatile__(				\
+			"int	$0x80\n\t"			\
+			: "=a"(retval)				\
+			: "0"(SYS_##fn),			\
+			  "b"((type1)(arg1))			\
+		);						\
+		if((int)retval < 0 && (int)retval > MAXERRNO) {	\
+			errno = -(retval);			\
+			retval = -1;				\
+			return (int)retval;			\
+		}						\
+		return retval;					\
+	}
+
+#define SYSCALL2(fn, retval, type1, type2)			\
+	int __sys_##fn(type1 arg1, type2 arg2)			\
+	{							\
+		unsigned int retval;				\
+								\
+		__asm__ __volatile__(				\
+			"int	$0x80\n\t"			\
+			: "=a"(retval)				\
+			: "0"(SYS_##fn),			\
+			  "b"((type1)(arg1)),			\
+			  "c"((type2)(arg2)) 			\
+		);						\
+		if((int)retval < 0 && (int)retval > MAXERRNO) {	\
+			errno = -(retval);			\
+			retval = -1;				\
+			return (int)retval;			\
+		}						\
+		return retval;					\
+	}
+
+#define SYSCALL3(fn, retval, type1, type2, type3)		\
+	int __sys_##fn(type1 arg1, type2 arg2, type3 arg3)	\
+	{							\
+		unsigned int retval;				\
+								\
+		__asm__ __volatile__(				\
+			"int	$0x80\n\t"			\
+			: "=a"(retval)				\
+			: "0"(SYS_##fn),			\
+			  "b"((type1)(arg1)),			\
+			  "c"((type2)(arg2)),			\
+			  "d"((type3)(arg3)) 			\
+		);						\
+		if((int)retval < 0 && (int)retval > MAXERRNO) {	\
+			errno = -(retval);			\
+			retval = -1;				\
+			return (int)retval;			\
+		}						\
+		return retval;					\
+	}
+
+#define SYSCALL4(fn, retval, type1, type2, type3, type4)	\
+	int __sys_##fn(type1 arg1, type2 arg2, type3 arg3, type4 arg4) \
+	{							\
+		unsigned int retval;				\
+								\
+		__asm__ __volatile__(				\
+			"int	$0x80\n\t"			\
+			: "=a"(retval)				\
+			: "0"(SYS_##fn),			\
+			  "b"((type1)(arg1)),			\
+			  "c"((type2)(arg2)),			\
+			  "d"((type3)(arg3)),			\
+			  "S"((type4)(arg4))			\
+		);						\
+		if((int)retval < 0 && (int)retval > MAXERRNO) {	\
+			errno = -(retval);			\
+			retval = -1;				\
+			return (int)retval;			\
+		}						\
+		return retval;					\
+	}
+
+#define SYSCALL5(fn, retval, type1, type2, type3, type4, type5)	\
+	int __sys_##fn(type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5) \
+	{							\
+		unsigned int retval;				\
+								\
+		__asm__ __volatile__(				\
+			"int	$0x80\n\t"			\
+			: "=a"(retval)				\
+			: "0"(SYS_##fn),			\
+			  "b"((type1)(arg1)),			\
+			  "c"((type2)(arg2)),			\
+			  "d"((type3)(arg3)),			\
+			  "S"((type4)(arg4)),			\
+			  "D"((type5)(arg5))			\
+		);						\
+		if((int)retval < 0 && (int)retval > MAXERRNO) {	\
+			errno = -(retval);			\
+			retval = -1;				\
+			return (int)retval;			\
+		}						\
+		return retval;					\
+	}
+
+#define SYSCALL6(fn, retval, type1, type2, type3, type4, type5, type6)	\
+	int __sys_##fn(type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6) \
+	{							\
+		unsigned int retval;				\
+								\
+		__asm__ __volatile__(				\
+			"pushl	%7\n\t"				\
+			"push	%%ebp\n\t"			\
+			"mov	4(%%esp),%%ebp\n\t"		\
+			"int	$0x80\n\t"			\
+			"pop	%%ebp\n\t"			\
+			"add	$4,%%esp\n\t"			\
+			: "=a"(retval)				\
+			: "0"(SYS_##fn),			\
+			  "b"((type1)(arg1)),			\
+			  "c"((type2)(arg2)),			\
+			  "d"((type3)(arg3)),			\
+			  "S"((type4)(arg4)),			\
+			  "D"((type5)(arg5)),			\
+			  "g"((type6)(arg6))			\
+		);						\
+		if((int)retval < 0 && (int)retval > MAXERRNO) {	\
+			errno = -(retval);			\
+			retval = -1;				\
+			return (int)retval;			\
+		}						\
+		return retval;					\
+	}
+
+#endif /* _SYSCALLS_H */
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/system.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/system.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/system.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/system.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,155 @@
+/* Copyright (C) 1991-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <errno.h>
+
+#ifndef	HAVE_GNU_LD
+#define	__environ	environ
+#endif
+
+#define	SHELL_PATH	"/bin/sh"	/* Path of the shell.  */
+#define	SHELL_NAME	"sh"		/* Name to give it.  */
+
+/* Execute LINE as a shell command, returning its status.  */
+int
+system (const char *line)
+{
+  int status, save;
+  pid_t pid;
+  struct sigaction sa, intr, quit;
+#ifndef WAITPID_CANNOT_BLOCK_SIGCHLD
+  sigset_t block, omask;
+#endif
+
+  if (line == NULL)
+    /* Check that we have a command processor available.  It might
+       not be available after a chroot(), for example.  */
+    return system ("exit 0") == 0;
+
+  sa.sa_handler = SIG_IGN;
+  sa.sa_flags = 0;
+  sigemptyset (&sa.sa_mask);
+
+  if (sigaction (SIGINT, &sa, &intr) < 0)
+    return -1;
+  if (sigaction (SIGQUIT, &sa, &quit) < 0)
+    {
+      save = errno;
+      (void) sigaction (SIGINT, &intr, (struct sigaction *) NULL);
+      errno = save;
+      return -1;
+    }
+
+#ifndef WAITPID_CANNOT_BLOCK_SIGCHLD
+
+/* SCO 3.2v4 has a bug where `waitpid' will never return if SIGCHLD is
+   blocked.  This makes it impossible for `system' to be implemented in
+   compliance with POSIX.2-1992.  They have acknowledged that this is a bug
+   but I have not seen nor heard of any forthcoming fix.  */
+
+  sigemptyset (&block);
+  sigaddset (&block, SIGCHLD);
+  save = errno;
+  if (sigprocmask (SIG_BLOCK, &block, &omask) < 0)
+    {
+      if (errno == ENOSYS)
+	errno = save;
+      else
+	{
+	  save = errno;
+	  (void) sigaction (SIGINT, &intr, (struct sigaction *) NULL);
+	  (void) sigaction (SIGQUIT, &quit, (struct sigaction *) NULL);
+	  errno = save;
+	  return -1;
+	}
+    }
+# define UNBLOCK sigprocmask (SIG_SETMASK, &omask, (sigset_t *) NULL)
+#else
+# define UNBLOCK 0
+#endif
+
+  pid = fork ();
+  if (pid == (pid_t) 0)
+    {
+      /* Child side.  */
+      const char *new_argv[4];
+      new_argv[0] = SHELL_NAME;
+      new_argv[1] = "-c";
+      new_argv[2] = line;
+      new_argv[3] = NULL;
+
+      /* Restore the signals.  */
+      (void) sigaction (SIGINT, &intr, (struct sigaction *) NULL);
+      (void) sigaction (SIGQUIT, &quit, (struct sigaction *) NULL);
+      (void) UNBLOCK;
+
+      /* Exec the shell.  */
+      (void) execve (SHELL_PATH, (char *const *) new_argv, __environ);
+      _exit (127);
+    }
+  else if (pid < (pid_t) 0)
+    /* The fork failed.  */
+    status = -1;
+  else
+    /* Parent side.  */
+    {
+#ifdef	NO_WAITPID
+      pid_t child;
+      do
+	{
+	  child = wait (&status);
+	  if (child <= -1 && errno != EINTR)
+	    {
+	      status = -1;
+	      break;
+	    }
+	  /* Note that pid cannot be <= -1 and therefore the loop continues
+	     when wait returned with EINTR.  */
+	}
+      while (child != pid);
+#else
+      int n;
+
+      do
+	n = waitpid (pid, &status, 0);
+      while (n == -1 && errno == EINTR);
+
+      if (n != pid)
+	status = -1;
+#endif
+    }
+
+  save = errno;
+  if ((sigaction (SIGINT, &intr, (struct sigaction *) NULL) |
+       sigaction (SIGQUIT, &quit, (struct sigaction *) NULL) |
+       UNBLOCK) != 0)
+    {
+      if (errno == ENOSYS)
+	errno = save;
+      else
+	return -1;
+    }
+
+  return status;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/termios.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/termios.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/termios.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/termios.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,128 @@
+/*
+ * fiwix/termios.c
+ *
+ * Copyright 2018-2020, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/termios.h>
+#include <sys/ioctl.h>
+#include <paths.h>
+
+static char __ctty[] = _PATH_TTY;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+int tcgetattr(int, struct termios *);
+int tcsetattr(int, int, const struct termios *);
+pid_t tcgetpgrp(int);
+int tcsetpgrp(int, pid_t);
+int tcflow(int, int);
+int tcflush(int, int);
+void cfmakeraw(struct termios *);
+int tcdrain(int);
+char *ctermid(char *);
+int tcsendbreak(int, int);
+*/
+
+
+int tcgetattr(int fd, struct termios *termios)
+{
+	return ioctl(fd, TCGETS, termios);
+}
+
+int tcsetattr(int fd, int optional_actions, const struct termios *termios)
+{
+	int cmd;
+
+	switch(optional_actions) {
+		case TCSANOW:
+			cmd = TCSETS;
+			break;
+		case TCSADRAIN:
+			cmd = TCSETSW;
+			break;
+		case TCSAFLUSH:
+			cmd = TCSETSF;
+			break;
+		default:
+			errno = EINVAL;
+			return -1;
+	}
+	return ioctl(fd, cmd, termios);
+}
+
+pid_t tcgetpgrp(int fd)
+{
+	int p;
+    
+	if(ioctl(fd, TIOCGPGRP, &p) < 0) {
+		return (pid_t)-1;
+	}
+	return (pid_t)p;
+}
+
+
+int tcsetpgrp(int fd, pid_t pid)
+{
+	int p;
+	
+	p = (int)pid;
+	return ioctl(fd, TIOCSPGRP, &p);
+}
+
+int tcflow(int fd, int action)
+{
+	return ioctl(fd, TCXONC, action);
+}
+
+int tcflush(int fd, int queue_selector)
+{
+	return ioctl(fd, TCFLSH, queue_selector);
+}
+
+/* this function is part of the GNU C Library */
+void cfmakeraw(struct termios *t)
+{
+	t->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);
+	t->c_oflag &= ~OPOST;
+	t->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
+	t->c_cflag &= ~(CSIZE|PARENB);
+	t->c_cflag |= CS8;
+	t->c_cc[VMIN] = 1;		/* read returns when one char is available */
+	t->c_cc[VTIME] = 0;
+}
+
+int tcdrain(int fd)
+{
+	return ioctl(fd, TCSBRK, 1);
+}
+
+char *ctermid(char *s)
+{
+	if(!s) {
+		return __ctty;
+	}
+
+	return strcpy(s, _PATH_TTY);
+}
+
+int tcsendbreak(int fd, int duration)
+{
+	if(duration <=0) {
+		return ioctl(fd, TCSBRK, 0);
+	}
+
+	errno = (EINVAL);
+	return -1;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/usershell.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/usershell.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/usershell.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/usershell.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,50 @@
+/*
+ * fiwix/usershell.c
+ *
+ * Copyright 2020, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <stdio.h>
+#include <paths.h>
+
+static const char _defshells[] = "/bin/sh\n/bin/csh\n";
+static FILE *_f;
+
+void setusershell(void)
+{
+	if(!_f) {
+		_f = fopen(_PATH_SHELLS, "r");
+	}
+	if(!_f) {
+		_f = fmemopen((void *)_defshells, strlen(_defshells), "r");
+	}
+}
+
+char *getusershell(void)
+{
+	static char line[1024];
+	int len;
+
+	if(!_f) {
+		setusershell();
+	}
+
+	if(!(fgets(line, 1024, _f))) {
+		return NULL;
+	}
+
+	len = strlen(line);
+	if(line[len - 1] == '\n') {
+		line[len - 1] = '\0';
+	}
+	return line;
+}
+
+void endusershell(void)
+{
+	if(_f) {
+		fclose(_f);
+	}
+	_f = NULL;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/utmp.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/utmp.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/utmp.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/utmp.c	2025-01-31 08:25:59 +0000
@@ -0,0 +1,88 @@
+/*
+ * fiwix/utmp.c
+ *
+ * Copyright 2018-2020, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/utmp.h>
+#include <sys/unistd.h>
+
+void pututline(struct utmp *ut)
+{
+	FILE *f;
+	struct utmp curr_ut;
+	char *flags;
+	int n;
+
+	if(!access(UTMP_FILE, F_OK)) {
+		flags = "r+";
+		if(!(f = fopen(UTMP_FILE, flags))) {
+			return;
+		}
+
+		while((n = fread(&curr_ut, sizeof(struct utmp), 1, f)) == 1) {
+			if(
+			  (RUN_LVL <= curr_ut.ut_type && curr_ut.ut_type <= OLD_TIME && ut->ut_type == curr_ut.ut_type)
+			  ||
+			  (INIT_PROCESS <= curr_ut.ut_type && curr_ut.ut_type <= DEAD_PROCESS && !strncmp(ut->ut_id, curr_ut.ut_id, sizeof(curr_ut.ut_id)))
+			) {
+				if((n = ftell(f)) < 0) {
+					fclose(f);
+					return;
+				}
+				if(fseek(f, n - sizeof(struct utmp), SEEK_SET) < 0) {
+					fclose(f);
+					return;
+				}
+				fwrite(ut, sizeof(struct utmp), 1, f);
+				fclose(f);
+				return;
+			}
+		}
+		fclose(f);
+		flags = "a";
+	} else {
+		flags = "w+";
+	}
+
+	if(!(f = fopen(UTMP_FILE, flags))) {
+		return;
+	}
+	fwrite(ut, sizeof(struct utmp), 1, f);
+	fclose(f);
+	return;
+}
+
+int updwtmp(char *file, struct utmp *ut)
+{
+	int fd, errno;
+	unsigned int offset;
+
+	errno = 0;
+	if((fd = open(file, O_WRONLY)) < 0) {
+		perror("fopen");
+		return -1;
+	}
+	offset = lseek(fd, 0, SEEK_END);
+	if(offset % sizeof(struct utmp) != 0) {
+		offset -= offset % sizeof(struct utmp);
+		ftruncate(fd, offset);
+
+		if(lseek(fd, 0, SEEK_END) < 0) {
+			close(fd);
+			return -1;
+		}
+	}
+	if(write(fd, ut, sizeof(struct utmp)) != sizeof(struct utmp)) {
+		ftruncate(fd, offset);
+		errno = -1;
+	}
+
+	close(fd);
+	return errno;
+}
diff -ruN newlib-4.4.0.20231231/newlib/libc/sys/fiwix/wrappers.c newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/wrappers.c
--- newlib-4.4.0.20231231/newlib/libc/sys/fiwix/wrappers.c	1970-01-01 00:00:00 +0000
+++ newlib-4.4.0.20231231.new/newlib/libc/sys/fiwix/wrappers.c	2025-04-07 15:50:39 +0000
@@ -0,0 +1,348 @@
+/*
+ * fiwix/wrappers.c
+ *
+ * Copyright 2018-2022, Jordi Sanfeliu. All rights reserved.
+ * Distributed under the terms of the Fiwix License.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <time.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/ustat.h>
+#include <sys/utsname.h>
+#include <unistd.h>
+
+#include <fiwix/limits.h>
+
+#if !defined(PAGE_SIZE)
+#define PAGE_SIZE      4096
+#endif
+
+static void *curr_brk = NULL;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+inline int MIN(int a, int b)
+{
+	return (a < b ? a : b);
+}
+
+inline int MAX(int a, int b)
+{
+	return (a > b ? a : b); 
+}
+
+int open(const char *pathname, int flags, ...)
+{
+	va_list args;
+	int mode, retval;
+
+	va_start(args, flags);
+	if(flags & O_CREAT) {
+		mode = va_arg(args, int);
+	}
+	va_end(args);
+	return __open(pathname, flags, mode);
+}
+
+#ifndef HAVE_NANOSLEEP
+/* posix/sleep.c includes already the sleep() function */
+unsigned int sleep(unsigned int seconds)
+{
+	struct timespec req, rem;
+	int retval;
+
+	req.tv_sec = seconds;
+	req.tv_nsec = 0;
+	if(!nanosleep(&req, &rem)) {
+		retval = 0;
+	} else {
+		retval = -1;
+	}
+	if(errno == EINTR) {
+		retval = rem.tv_sec;
+	}
+	return retval;
+}
+#endif
+
+/* not needed, is in 'libc/posix/usleep.c'
+int usleep(useconds_t usec)
+{
+	struct timespec req, rem;
+	int retval;
+
+	req.tv_sec = usec / 1000000;
+	req.tv_nsec = (usec & 1000000) * 1000;
+	if(!nanosleep(&req, &rem)) {
+		retval = 0;
+	} else {
+		retval = -1;
+	}
+	if(errno == EINTR) {
+		retval = rem.tv_sec;
+	}
+	return retval;
+}
+*/
+
+int mkfifo(const char *pathname, mode_t mode)
+{
+	return mknod(pathname, mode | S_IFIFO, 0);
+}
+
+void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)
+{
+	struct mmap mmap;
+
+	mmap.start = (unsigned int)addr;
+	mmap.length = len;
+	mmap.prot = prot;
+	mmap.flags = flags;
+	mmap.fd = fd;
+	mmap.offset = offset;
+
+	return (void *)old_mmap(&mmap);
+}
+
+int brk(void *addr)
+{
+	void *new_brk;
+
+	new_brk = (void *)__brk(addr);
+	if(new_brk != addr) {
+		errno = ENOMEM;
+		return -1;
+	}
+	curr_brk = new_brk;
+	return 0;
+}
+
+void *sbrk(ptrdiff_t increment)
+{
+	void *old_brk, *new_brk;
+
+	if(!curr_brk) {
+		curr_brk = (void *)__brk(NULL);
+	}
+	new_brk = (void *)__brk(curr_brk + increment);
+	if(new_brk != (curr_brk + increment)) {
+		errno = ENOMEM;
+		return (void *)-1;
+	}
+	old_brk = curr_brk;
+	curr_brk = new_brk;
+	return old_brk;
+}
+
+int fcntl(int fd, int cmd, ...)
+{
+	va_list args;
+	int arg;
+
+	va_start(args, cmd);
+	switch(cmd) {
+		case F_DUPFD:
+		case F_SETFD:
+		case F_SETFL:
+		case F_SETOWN:
+		case F_GETLK:
+		case F_SETLK:
+			arg = va_arg(args, int);
+			break;
+		default:
+			arg = 0;
+			break;
+	}
+	va_end(args);
+	return __fcntl(fd, cmd, arg);
+}
+
+pid_t wait(int *status)
+{
+	waitpid(-1, status, 0);
+}
+
+long sysconf(int name)
+{
+	switch(name) {
+		case _SC_ARG_MAX:
+#ifdef ARG_MAX
+			return ARG_MAX * 4096;
+#endif
+			break;
+		case _SC_CHILD_MAX:
+#ifdef CHILD_MAX
+			return CHILD_MAX;
+#endif
+			break;
+		case _SC_OPEN_MAX:
+#ifdef OPEN_MAX
+			return OPEN_MAX;
+#endif
+			break;
+		case _SC_PAGESIZE:
+#ifdef PAGE_SIZE
+			return PAGE_SIZE;
+#endif
+			break;
+		default:
+			errno = EINVAL;
+			break;
+	}
+	return -1;
+}
+
+int getpagesize(void)
+{
+	return PAGE_SIZE;
+}
+
+dev_t makedev(unsigned int __major, unsigned int __minor)
+{
+	dev_t __dev;
+
+	__dev = ((dev_t)__major << 8) & 0xFF00;
+	__dev |= (dev_t)__minor & 0x00FF;
+	return __dev;
+}
+
+int _rename(const char *old, const char *new)
+{
+	return __rename(old, new);
+}
+
+int seteuid(uid_t __uid)
+{
+	return setreuid(-1, __uid);
+}
+
+int setegid(gid_t __gid)
+{
+	return setregid(-1, __gid);
+}
+
+long fpathconf(int fd, int name)
+{
+	return -ENOSYS;
+}
+long pathconf(const char *path, int name)
+{
+	return -ENOSYS;
+}
+
+int gethostname(char *name, size_t len)
+{
+	struct utsname buf;
+	size_t node_len;
+	int errno;
+
+	if((errno = uname(&buf))) {
+		return errno;
+	}
+
+	node_len = strlen(buf.nodename) + 1;
+	memcpy(name, buf.nodename, MIN(len, node_len));
+	if(node_len > len) {
+		return -ENAMETOOLONG;
+	}
+	return 0;
+}
+
+int sigmask(int signum)
+{
+	return 1 << signum;
+}
+
+int sigblock(int mask)
+{
+	return ssetmask(mask | sgetmask());
+}
+
+int sigsetmask(int newmask)
+{
+	ssetmask(newmask);
+}
+
+unsigned int htonl(unsigned int hostlong)
+{
+	unsigned char tmp[4];
+	unsigned int result;
+
+	tmp[0] = (unsigned char)((hostlong >> 24) & 0xFF);
+	tmp[1] = (unsigned char)((hostlong >> 16) & 0xFF);
+	tmp[2] = (unsigned char)((hostlong >> 8) & 0xFF);
+	tmp[3] = (unsigned char)(hostlong & 0xFF);
+
+	memcpy(&result, tmp, sizeof(tmp));
+	return result;
+}
+
+unsigned int ntohl(unsigned int hostlong)
+{
+	return htonl(hostlong);
+}
+ 
+unsigned short htons(unsigned short hostshort)
+{
+	unsigned char tmp[2];
+	unsigned short result;
+
+	tmp[0] = (unsigned char)((hostshort >> 8) & 0xFF);
+	tmp[1] = (unsigned char)(hostshort & 0xFF);
+
+	memcpy(&result, tmp, sizeof(tmp));
+	return result;
+}
+
+unsigned short ntohs(unsigned short hostshort)
+{
+	return htons(hostshort);
+}
+
+int issetugid(void)
+{
+	if(getuid() != geteuid()) {
+		return 1;
+	}
+
+	if(getgid() != getegid()) {
+		return 1;
+	}
+}
+
+int getentropy(void *buffer, size_t length)
+{
+	int fd, retval;
+
+	if(length > 256) {
+		return -EINVAL;
+	}
+
+	fd = open("/dev/random", O_RDONLY, 0);
+	if(fd < 0) {
+		retval = -ENOSYS;
+	} else {
+		if(read(fd, (void *)buffer, length) == (size_t)length) {
+			retval = 0;
+		} else {
+			retval = -ENOSYS;
+		}
+		close(fd);
+	}
+	return retval;
+}
+
+ 
+#ifdef __cplusplus
+}
+#endif
